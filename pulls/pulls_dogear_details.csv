,pullid,pulls_number,pulltitle,pullsbody,pullsuserlogin,pullsuserid,pullauthordate,author_association,merged_status,stats_addns,stats_delns,stats_changed_files,pull_repo_desc,pull_repo_lang,pull_commit_sha,pull_commit_message
0,https://api.github.com/repos/mozilla/dogear/pulls/63,63,Updated token for github deployment,,lougeniaC64,5533446,2021-04-15T17:35:21Z,CONTRIBUTOR,True,1,1,1,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,bc0a463ca47db030c4a4db7c30e791253c02513d,Updated token for github deployment
1,https://api.github.com/repos/mozilla/dogear/pulls/61,61,Improve error message for cycles,😈,linacambridge,41387967,2020-04-15T19:56:28Z,CONTRIBUTOR,False,6,3,1,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,6674d09b0e815ccd61b9ab7791abb782e8cf9d8a,Improve error message for cycles.
2,https://api.github.com/repos/mozilla/dogear/pulls/60,60,Added functionality to break cycles,Fixes #55 ,lougeniaC64,5533446,2020-03-24T20:27:18Z,CONTRIBUTOR,False,69,42,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,bcf54bcc696d9338409dc0561afd5ee5d285e8e1,Added functionality to break cycles
3,https://api.github.com/repos/mozilla/dogear/pulls/60,60,Added functionality to break cycles,Fixes #55 ,lougeniaC64,5533446,2020-03-24T20:27:18Z,CONTRIBUTOR,False,69,42,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,26a2c1293ae471fef998a6d77c65cc174017fb3d,hot mess commit
4,https://api.github.com/repos/mozilla/dogear/pulls/60,60,Added functionality to break cycles,Fixes #55 ,lougeniaC64,5533446,2020-03-24T20:27:18Z,CONTRIBUTOR,False,69,42,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,4a6c0cf2f90e271dfb4f9f8a693698e65685fd90,Experimenting with creating items
5,https://api.github.com/repos/mozilla/dogear/pulls/60,60,Added functionality to break cycles,Fixes #55 ,lougeniaC64,5533446,2020-03-24T20:27:18Z,CONTRIBUTOR,False,69,42,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,37dee5a6f1cdaf3a9e248b57b178ee2038ad804d,More experimenting...
6,https://api.github.com/repos/mozilla/dogear/pulls/60,60,Added functionality to break cycles,Fixes #55 ,lougeniaC64,5533446,2020-03-24T20:27:18Z,CONTRIBUTOR,False,69,42,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,3aef16e41a6d6a8963777f0c74f7eb28abbf3c6a,Fixed break_cycles function
7,https://api.github.com/repos/mozilla/dogear/pulls/60,60,Added functionality to break cycles,Fixes #55 ,lougeniaC64,5533446,2020-03-24T20:27:18Z,CONTRIBUTOR,False,69,42,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,2f416bea1a8dc40eda3cbfce107b23fda8e16c3e,Added unfiled entry to parents in try_from func
8,https://api.github.com/repos/mozilla/dogear/pulls/60,60,Added functionality to break cycles,Fixes #55 ,lougeniaC64,5533446,2020-03-24T20:27:18Z,CONTRIBUTOR,False,69,42,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,dad94733cd28d01905a41e189ea99e00a97d6c00,"Removed break_cycles, added detect_cycle_start"
9,https://api.github.com/repos/mozilla/dogear/pulls/60,60,Added functionality to break cycles,Fixes #55 ,lougeniaC64,5533446,2020-03-24T20:27:18Z,CONTRIBUTOR,False,69,42,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,4ce6aa71c7a3be5ce7e527cffbe04ad9b5c9a6de,Removed commented code from cycle test
10,https://api.github.com/repos/mozilla/dogear/pulls/59,59,Recorded invalid items as tree problem,"This commit fixes #58. 

It includes the addition of `Problem::InvalidItem` and `ProblemCounts::invalid_items` and functionality to track the occurrences of invalid items.",lougeniaC64,5533446,2020-03-16T20:42:25Z,CONTRIBUTOR,True,22,1,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,41b498c6fa9ad6270cf7268b5399e45eb57e8a69,Recorded invalid items as tree problem
11,https://api.github.com/repos/mozilla/dogear/pulls/56,56,Include Kind and Guid in error messages,"This PR addresses #54.

Simply put, we should be able to see both the item `Kind` and `Guid` in any error message produced by `tree::Builder`.

Currently I have only done `MismatchedItemKind` and `InvalidParent`. I have some questions about the design-- after they're answered I'll  update the rest!",mbStavola,155693,2019-10-06T22:16:00Z,CONTRIBUTOR,True,88,23,3,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,e80f0d73fe3c953af8a88542e442591284b2075c,Include guid in the message for MismatchedItemKind
12,https://api.github.com/repos/mozilla/dogear/pulls/56,56,Include Kind and Guid in error messages,"This PR addresses #54.

Simply put, we should be able to see both the item `Kind` and `Guid` in any error message produced by `tree::Builder`.

Currently I have only done `MismatchedItemKind` and `InvalidParent`. I have some questions about the design-- after they're answered I'll  update the rest!",mbStavola,155693,2019-10-06T22:16:00Z,CONTRIBUTOR,True,88,23,3,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,768d5d93d47b8f20b9487c5772ca41f2e9105ffd,Add kinds to InvalidParent
13,https://api.github.com/repos/mozilla/dogear/pulls/56,56,Include Kind and Guid in error messages,"This PR addresses #54.

Simply put, we should be able to see both the item `Kind` and `Guid` in any error message produced by `tree::Builder`.

Currently I have only done `MismatchedItemKind` and `InvalidParent`. I have some questions about the design-- after they're answered I'll  update the rest!",mbStavola,155693,2019-10-06T22:16:00Z,CONTRIBUTOR,True,88,23,3,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,0b782ddf376bb4c42b2a039b66ec1699b88feb8f,Add variants for unknown child items
14,https://api.github.com/repos/mozilla/dogear/pulls/53,53,Emit completion ops for tombstones,"This commit adds completion ops for deleting local items (to apply
remote tombstones), inserting new tombstones (to delete non-syncable
and invalid items), and uploading tombstones (to avoid an extra table
scan when staging outgoing tombstones).

These ops also help avoid extra work when applying tombstones for items
that don't exist locally, or uploading tombstones for items that don't
exist remotely.",linacambridge,41387967,2019-09-10T07:51:56Z,CONTRIBUTOR,True,401,237,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,8185f8c6f47f229cfdc6bf5ce6b18b238bed8842,"Rename completion ops to clarify if they're local or remote.

It's unclear if `flag_{for_upload, as_merged}` and `skip_upload`
refer to local or remote items. This commit renames them to be more
consistent:

* `SetLocalUnmerged` (formerly `FlagForUpload`) marks a local item as
  needing to be merged.
* `SetLocalMerged` (formerly `SkipUpload`) removes the ""needs merge""
  flag from a local item.
* `SetRemoteMerged` (formerly `FlagAsMerged`) removes the ""needs merge""
  flag from a _remote_ item.

This commit also renames `Upload` to `UploadItems`, since we'll be
adding completion ops for uploading tombstones next."
15,https://api.github.com/repos/mozilla/dogear/pulls/53,53,Emit completion ops for tombstones,"This commit adds completion ops for deleting local items (to apply
remote tombstones), inserting new tombstones (to delete non-syncable
and invalid items), and uploading tombstones (to avoid an extra table
scan when staging outgoing tombstones).

These ops also help avoid extra work when applying tombstones for items
that don't exist locally, or uploading tombstones for items that don't
exist remotely.",linacambridge,41387967,2019-09-10T07:51:56Z,CONTRIBUTOR,True,401,237,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,5f66b493c3e73b57f6d302839af3b8248d5c2c6a,"Emit completion ops for tombstones.

This commit adds completion ops for deleting local items (to apply
remote tombstones), inserting new tombstones (to delete non-syncable
and invalid items), and uploading tombstones (to avoid an extra table
scan when staging outgoing tombstones).

These ops also help avoid extra work when applying tombstones for items
that don't exist locally, or uploading tombstones for items that don't
exist remotely."
16,https://api.github.com/repos/mozilla/dogear/pulls/53,53,Emit completion ops for tombstones,"This commit adds completion ops for deleting local items (to apply
remote tombstones), inserting new tombstones (to delete non-syncable
and invalid items), and uploading tombstones (to avoid an extra table
scan when staging outgoing tombstones).

These ops also help avoid extra work when applying tombstones for items
that don't exist locally, or uploading tombstones for items that don't
exist remotely.",linacambridge,41387967,2019-09-10T07:51:56Z,CONTRIBUTOR,True,401,237,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,0e5b63e1d5c0b6f49741abdf37f58cfea5d510e6,"Refactor handling of deletion ops.

We now emit ops in two steps. The first step removes all local
tombstones, and flags remote tombstones as merged, for all revived
items. The second handles the actual deletion, on either or both sides.

* Don't add deletions from local and remote trees that aren't
  mentioned in `delete_remotely` and `delete_locally`, because we emit
  different completion ops for those.
* Change `Tree::guids` to only return GUIDs that exist in the tree,
  not deleted GUIDs.
* Change `Tree::deletions` to return a `HashSet` instead of an
  iterator, so that we can use the `difference` method.
* Add `Tree::exists`.
* Remove `Tree::record_for_guid`.
* Add `CompletionOps::summarize` for tests and logging.
* Remove `StructureCounts::merged_deletions`, since it's not accurate
  anymore."
17,https://api.github.com/repos/mozilla/dogear/pulls/53,53,Emit completion ops for tombstones,"This commit adds completion ops for deleting local items (to apply
remote tombstones), inserting new tombstones (to delete non-syncable
and invalid items), and uploading tombstones (to avoid an extra table
scan when staging outgoing tombstones).

These ops also help avoid extra work when applying tombstones for items
that don't exist locally, or uploading tombstones for items that don't
exist remotely.",linacambridge,41387967,2019-09-10T07:51:56Z,CONTRIBUTOR,True,401,237,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,af00f1478de386955057ad84637e549913d992b7,Report local and remote deletions in tree stats.
18,https://api.github.com/repos/mozilla/dogear/pulls/53,53,Emit completion ops for tombstones,"This commit adds completion ops for deleting local items (to apply
remote tombstones), inserting new tombstones (to delete non-syncable
and invalid items), and uploading tombstones (to avoid an extra table
scan when staging outgoing tombstones).

These ops also help avoid extra work when applying tombstones for items
that don't exist locally, or uploading tombstones for items that don't
exist remotely.",linacambridge,41387967,2019-09-10T07:51:56Z,CONTRIBUTOR,True,401,237,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,5707548d060d989c308b46dbf99acff6a77c13e8,"Make fetching completion ops abortable.

This commit adds `MergedRoot::completion_ops_with_signal`, and
implements `MergedRoot::completion_ops` in terms of it."
19,https://api.github.com/repos/mozilla/dogear/pulls/53,53,Emit completion ops for tombstones,"This commit adds completion ops for deleting local items (to apply
remote tombstones), inserting new tombstones (to delete non-syncable
and invalid items), and uploading tombstones (to avoid an extra table
scan when staging outgoing tombstones).

These ops also help avoid extra work when applying tombstones for items
that don't exist locally, or uploading tombstones for items that don't
exist remotely.",linacambridge,41387967,2019-09-10T07:51:56Z,CONTRIBUTOR,True,401,237,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,188fd6b8ee75f17590b5d2f56e1f9f60cff0f37b,"Revert storing extra tombstones in `delete_{locally, remotely}`.

Instead of panicking if a GUID in `delete_locally` or `delete_remotely`
doesn't exist on both sides, we now clean up local tombstones, and
flag the remote tombstone as merged.

With this change, we no longer need to filter out local and remote
tombstones for items that don't exist on the other side. That means
we can revert `Tree::guids` to return all GUIDs, including deletions,
and have `MergedRoot::{local, remote}_deletions` return a more accurate
set of tombstones for logging."
20,https://api.github.com/repos/mozilla/dogear/pulls/53,53,Emit completion ops for tombstones,"This commit adds completion ops for deleting local items (to apply
remote tombstones), inserting new tombstones (to delete non-syncable
and invalid items), and uploading tombstones (to avoid an extra table
scan when staging outgoing tombstones).

These ops also help avoid extra work when applying tombstones for items
that don't exist locally, or uploading tombstones for items that don't
exist remotely.",linacambridge,41387967,2019-09-10T07:51:56Z,CONTRIBUTOR,True,401,237,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,51e638edf3d4df7ddae384e76c6546d1a7b21f16,Improve completion op summaries.
21,https://api.github.com/repos/mozilla/dogear/pulls/53,53,Emit completion ops for tombstones,"This commit adds completion ops for deleting local items (to apply
remote tombstones), inserting new tombstones (to delete non-syncable
and invalid items), and uploading tombstones (to avoid an extra table
scan when staging outgoing tombstones).

These ops also help avoid extra work when applying tombstones for items
that don't exist locally, or uploading tombstones for items that don't
exist remotely.",linacambridge,41387967,2019-09-10T07:51:56Z,CONTRIBUTOR,True,401,237,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,558ee66ee1e3c08cc8498f4a62ba251c6649e825,Add a `to_strings` helper.
22,https://api.github.com/repos/mozilla/dogear/pulls/53,53,Emit completion ops for tombstones,"This commit adds completion ops for deleting local items (to apply
remote tombstones), inserting new tombstones (to delete non-syncable
and invalid items), and uploading tombstones (to avoid an extra table
scan when staging outgoing tombstones).

These ops also help avoid extra work when applying tombstones for items
that don't exist locally, or uploading tombstones for items that don't
exist remotely.",linacambridge,41387967,2019-09-10T07:51:56Z,CONTRIBUTOR,True,401,237,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,b6a900cac607b0ffbf5f4253561a4d7ea78d78d0,Remove unnecessary closure for `Guid::as_str`.
23,https://api.github.com/repos/mozilla/dogear/pulls/52,52,Ensure possible remote dupes don't exist locally.,"We ignored local child nodes that existed in the remote tree, but
didn't check if the remote node existed in the local tree. This
meant we might dedupe multiple local items to the same remote
item.

This showed up as a UNIQUE constraint violation on Desktop.",linacambridge,41387967,2019-08-20T00:25:56Z,CONTRIBUTOR,True,156,62,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,d749e931863a7b9c26fcdf66639ea1377c3082c7,"Ensure possible remote dupes don't exist locally.

We ignored local child nodes that existed in the remote tree, but
didn't check if the remote node existed in the local tree. This
meant we might dedupe multiple local items to the same remote
item.

This showed up as a UNIQUE constraint violation on Desktop."
24,https://api.github.com/repos/mozilla/dogear/pulls/50,50,Rolling PR for Dogear changes to reduce SQLite full table scans,,linacambridge,41387967,2019-07-26T01:32:28Z,CONTRIBUTOR,True,1083,1042,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,42dabe62196c83b4a2e4c8dc1534b013beb91fe5,"Remove `Store::fetch_new_{local, remote}_contents`.

In Rust Places and `bookmark_sync` on Desktop, fetching the tree and
contents runs two table scans: one to build the structure, and one to
fetch content info for deduping. Since the latter can't use an index,
it's more efficient to fetch content info during the first scan to
build the tree.

This commit adds a builder API to set content info, and stores it with
the item instead of a separate map."
25,https://api.github.com/repos/mozilla/dogear/pulls/50,50,Rolling PR for Dogear changes to reduce SQLite full table scans,,linacambridge,41387967,2019-07-26T01:32:28Z,CONTRIBUTOR,True,1083,1042,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,4d1b2211329382a750236c940d8552d3b4a89336,"Replace `Tree::note_deleted` with `Builder::deletion`.

This lets us note deletions as we build the tree, avoiding a second
table scan on the synced bookmarks table to fetch deletions. This also
means we can report validation telemetry for deleted parents and
children separately from missing ones."
26,https://api.github.com/repos/mozilla/dogear/pulls/50,50,Rolling PR for Dogear changes to reduce SQLite full table scans,,linacambridge,41387967,2019-07-26T01:32:28Z,CONTRIBUTOR,True,1083,1042,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,7883c1e17201e6a8f01fd38a75c96c57fa4a7a1a,Note deleted parents and children.
27,https://api.github.com/repos/mozilla/dogear/pulls/50,50,Rolling PR for Dogear changes to reduce SQLite full table scans,,linacambridge,41387967,2019-07-26T01:32:28Z,CONTRIBUTOR,True,1083,1042,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,bc683af66d36d17f0e2540258dbaff81fd5a18de,"Move more methods to `MergedRoot`.

* Change `Merger::merge` to consume the merger, and check if the merged
  tree subsumes the local and remote trees before returning a merged
  root.
* Remove `Merger::subsumes`.
* Move `Merger::{deletions, local_deletions, remote_deletions, counts}`
  to `MergedRoot`.
* Add `MergedRoot::completion_ops_with_filter`, to let callers discard
  completion ops. Desktop uses this to ignore position changes to user
  content roots,
* Move `MergedRoot::to_ascii_string` to `MergedNode`.
* Add a `FlagAsMerged` completion op, to flag fully merged remote items
  and tombstones. This is the motivation for this refactor, since we
  need the set of deletions and both trees to emit these ops.
* Change `Store::apply` to only take a `MergedRoot`, since
  `MergedRoot::deletions` exists now."
28,https://api.github.com/repos/mozilla/dogear/pulls/50,50,Rolling PR for Dogear changes to reduce SQLite full table scans,,linacambridge,41387967,2019-07-26T01:32:28Z,CONTRIBUTOR,True,1083,1042,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,1626ea6a837e46aa2aca0c452458d1f57e50d5ff,"Remove positions from `Content::Separator`.

The merger already knows the positions of all children, there's
no need to include it in the content info. This also lets us avoid a
left join on the structure table when inflating the remote tree in
Desktop and a-s."
29,https://api.github.com/repos/mozilla/dogear/pulls/50,50,Rolling PR for Dogear changes to reduce SQLite full table scans,,linacambridge,41387967,2019-07-26T01:32:28Z,CONTRIBUTOR,True,1083,1042,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,487ca47fd276bc7999664e57c85f3d9ed17d9c97,"Treat the tags root as a content root.

This makes it easier for Desktop to build a complete tree."
30,https://api.github.com/repos/mozilla/dogear/pulls/50,50,Rolling PR for Dogear changes to reduce SQLite full table scans,,linacambridge,41387967,2019-07-26T01:32:28Z,CONTRIBUTOR,True,1083,1042,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,f32ca3f46c1d4211eaceadeb8475f6635b0289a8,"Always check for changed GUIDs and new structure in `accumulate`.

This avoids emitting extra `ApplyNewLocalStructure` for remotely
changed items in folders with new local structure."
31,https://api.github.com/repos/mozilla/dogear/pulls/50,50,Rolling PR for Dogear changes to reduce SQLite full table scans,,linacambridge,41387967,2019-07-26T01:32:28Z,CONTRIBUTOR,True,1083,1042,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,a135cc0a14e559e952019895c57dc83b39e86550,"Explicitly call `Driver::max_log_level` in the logging macros.

The `Driver` trait no longer needs to be in scope to use the macros."
32,https://api.github.com/repos/mozilla/dogear/pulls/50,50,Rolling PR for Dogear changes to reduce SQLite full table scans,,linacambridge,41387967,2019-07-26T01:32:28Z,CONTRIBUTOR,True,1083,1042,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,9a43ebbdc1b957358aeedf7973bc93cc15a1b29a,Make the logging in `Store::merge_with_driver` less chatty.
33,https://api.github.com/repos/mozilla/dogear/pulls/50,50,Rolling PR for Dogear changes to reduce SQLite full table scans,,linacambridge,41387967,2019-07-26T01:32:28Z,CONTRIBUTOR,True,1083,1042,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,791d8f4a7913d3f27ab3911d7a6115bd76776631,"Split `FlagForUpload` into a separate completion op.

We now emit `FlagForUpload` to update the local change counter
(matching `FlagAsMerged`), and emit `Upload` for all items that should
be uploaded. This lets us avoid another full table scan when staging
outgoing items."
34,https://api.github.com/repos/mozilla/dogear/pulls/50,50,Rolling PR for Dogear changes to reduce SQLite full table scans,,linacambridge,41387967,2019-07-26T01:32:28Z,CONTRIBUTOR,True,1083,1042,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,00c01872e031732c8b2a0de027130699c88e63d8,"Add docs for new public methods, and improve some comments."
35,https://api.github.com/repos/mozilla/dogear/pulls/48,48,Use Tarpaulin for code coverage,"kcov's stats are suuuper off, and Tarpaulin worked like a charm for @thomcc! Also, that name... 😍",linacambridge,41387967,2019-07-17T21:06:28Z,CONTRIBUTOR,True,9,33,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,a254e72ce1e75597cb7264010c3ec6e560ce71b8,Use Tarpaulin for code coverage.
36,https://api.github.com/repos/mozilla/dogear/pulls/47,47, Improve handling for unchanged and locally changed items,"This PR overhauls how the merger records and applies local changes.
Before, new structure was only used to flag merged items for
reupload. Consumers would apply the merged tree by storing all merge
states in an SQLite temp table, then firing triggers that examined and
updated every item. This was inefficient, and the process could take
several seconds for a large tree on Desktop.

To improve this, we introduce two concepts: new local structure, and
completion operations.

New local structure is the analog to new remote structure, and is set
for all items with newer local changes that are reparented or
repositioned in the merged tree. (Remote-only items, and items with
newer remote changes, have new local structure by definition). The
merger now flags relocated orphans, deleted non-syncable and invalid
items, items with deduped and changed GUIDs, reparented items, and
folders with moved children, as having new local structure.

Merging now produces a sequence of completion operations, instead of
raw merged descendants. Completion ops describe how to update the local
tree so that it matches the remote tree. These include changing GUIDs,
taking remote items, applying new structure, and updating change
counters. We try to avoid emitting completion ops for items that didn't
change (like children of a folder with new local structure that have
the same positions) to avoid unnecessary database work. The name
""completion ops"" comes from Firefox for iOS, which had a similar
concept in its old bookmark sync implementation.

Additionally, the ""unchanged"" merge state really means unchanged now.
Before, it meant something like ""unchanged, possibly with new
children"". ""Unchanged with new local structure"" is a new state that's
used for roots, where we want to apply merged children, but not a
synced root's title. We compare child GUIDs to determine if a folder's
local and remote children are unchanged, and use a new
`merge_unchanged_child_into_merged_node` method that skips checking for
moved children.

Finally, we now check validity when determining which side to take, and
pick the valid side even if it's unchanged or older.

Closes #46.",linacambridge,41387967,2019-07-17T17:49:30Z,CONTRIBUTOR,True,1240,666,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,48b24ba60cecac5b12b39fb50ed6c5bde82996fe,"Improve handling for unchanged and locally changed items.

This commit overhauls how the merger records and applies local changes.
Before, new structure was only used to flag merged items for
reupload. Consumers would apply the merged tree by storing all merge
states in an SQLite temp table, then firing triggers that examined and
updated every item. This was inefficient, and the process could take
several seconds for a large tree on Desktop.

To improve this, we introduce two concepts: new local structure, and
completion operations.

New local structure is the analog to new remote structure, and is set
for all items with newer local changes that are reparented or
repositioned in the merged tree. (Remote-only items, and items with
newer remote changes, have new local structure by definition). The
merger now flags relocated orphans, deleted non-syncable and invalid
items, items with deduped and changed GUIDs, reparented items, and
folders with moved children, as having new local structure.

Merging now produces a sequence of completion operations, instead of
raw merged descendants. Completion ops describe how to update the local
tree so that it matches the remote tree. These include changing GUIDs,
taking remote items, applying new structure, and updating change
counters. We try to avoid emitting completion ops for items that didn't
change (like children of a folder with new local structure that have
the same positions) to avoid unnecessary database work. The name
""completion ops"" comes from Firefox for iOS, which had a similar
concept in its old bookmark sync implementation.

Additionally, the ""unchanged"" merge state really means unchanged now.
Before, it meant something like ""unchanged, possibly with new
children"". ""Unchanged with new local structure"" is a new state that's
used for roots, where we want to apply merged children, but not a
synced root's title. We compare child GUIDs to determine if a folder's
local and remote children are unchanged, and use a new
`merge_unchanged_child_into_merged_node` method that skips checking for
moved children.

Finally, we now check validity when determining which side to take, and
pick the valid side even if it's unchanged or older.

Closes #46."
37,https://api.github.com/repos/mozilla/dogear/pulls/47,47, Improve handling for unchanged and locally changed items,"This PR overhauls how the merger records and applies local changes.
Before, new structure was only used to flag merged items for
reupload. Consumers would apply the merged tree by storing all merge
states in an SQLite temp table, then firing triggers that examined and
updated every item. This was inefficient, and the process could take
several seconds for a large tree on Desktop.

To improve this, we introduce two concepts: new local structure, and
completion operations.

New local structure is the analog to new remote structure, and is set
for all items with newer local changes that are reparented or
repositioned in the merged tree. (Remote-only items, and items with
newer remote changes, have new local structure by definition). The
merger now flags relocated orphans, deleted non-syncable and invalid
items, items with deduped and changed GUIDs, reparented items, and
folders with moved children, as having new local structure.

Merging now produces a sequence of completion operations, instead of
raw merged descendants. Completion ops describe how to update the local
tree so that it matches the remote tree. These include changing GUIDs,
taking remote items, applying new structure, and updating change
counters. We try to avoid emitting completion ops for items that didn't
change (like children of a folder with new local structure that have
the same positions) to avoid unnecessary database work. The name
""completion ops"" comes from Firefox for iOS, which had a similar
concept in its old bookmark sync implementation.

Additionally, the ""unchanged"" merge state really means unchanged now.
Before, it meant something like ""unchanged, possibly with new
children"". ""Unchanged with new local structure"" is a new state that's
used for roots, where we want to apply merged children, but not a
synced root's title. We compare child GUIDs to determine if a folder's
local and remote children are unchanged, and use a new
`merge_unchanged_child_into_merged_node` method that skips checking for
moved children.

Finally, we now check validity when determining which side to take, and
pick the valid side even if it's unchanged or older.

Closes #46.",linacambridge,41387967,2019-07-17T17:49:30Z,CONTRIBUTOR,True,1240,666,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,67f9557402af88cb3381934da23b61303bbcf4cc,"Update tests to check for merged structure state.

This is more comprehensive than checking if an item should be
reuploaded."
38,https://api.github.com/repos/mozilla/dogear/pulls/47,47, Improve handling for unchanged and locally changed items,"This PR overhauls how the merger records and applies local changes.
Before, new structure was only used to flag merged items for
reupload. Consumers would apply the merged tree by storing all merge
states in an SQLite temp table, then firing triggers that examined and
updated every item. This was inefficient, and the process could take
several seconds for a large tree on Desktop.

To improve this, we introduce two concepts: new local structure, and
completion operations.

New local structure is the analog to new remote structure, and is set
for all items with newer local changes that are reparented or
repositioned in the merged tree. (Remote-only items, and items with
newer remote changes, have new local structure by definition). The
merger now flags relocated orphans, deleted non-syncable and invalid
items, items with deduped and changed GUIDs, reparented items, and
folders with moved children, as having new local structure.

Merging now produces a sequence of completion operations, instead of
raw merged descendants. Completion ops describe how to update the local
tree so that it matches the remote tree. These include changing GUIDs,
taking remote items, applying new structure, and updating change
counters. We try to avoid emitting completion ops for items that didn't
change (like children of a folder with new local structure that have
the same positions) to avoid unnecessary database work. The name
""completion ops"" comes from Firefox for iOS, which had a similar
concept in its old bookmark sync implementation.

Additionally, the ""unchanged"" merge state really means unchanged now.
Before, it meant something like ""unchanged, possibly with new
children"". ""Unchanged with new local structure"" is a new state that's
used for roots, where we want to apply merged children, but not a
synced root's title. We compare child GUIDs to determine if a folder's
local and remote children are unchanged, and use a new
`merge_unchanged_child_into_merged_node` method that skips checking for
moved children.

Finally, we now check validity when determining which side to take, and
pick the valid side even if it's unchanged or older.

Closes #46.",linacambridge,41387967,2019-07-17T17:49:30Z,CONTRIBUTOR,True,1240,666,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,9ed02f4065c7f4efcf9a2e9be44a9e02a8f21b2d,Split `UpdateSyncChangeCounter` into `Upload` and `SkipUpload`.
39,https://api.github.com/repos/mozilla/dogear/pulls/47,47, Improve handling for unchanged and locally changed items,"This PR overhauls how the merger records and applies local changes.
Before, new structure was only used to flag merged items for
reupload. Consumers would apply the merged tree by storing all merge
states in an SQLite temp table, then firing triggers that examined and
updated every item. This was inefficient, and the process could take
several seconds for a large tree on Desktop.

To improve this, we introduce two concepts: new local structure, and
completion operations.

New local structure is the analog to new remote structure, and is set
for all items with newer local changes that are reparented or
repositioned in the merged tree. (Remote-only items, and items with
newer remote changes, have new local structure by definition). The
merger now flags relocated orphans, deleted non-syncable and invalid
items, items with deduped and changed GUIDs, reparented items, and
folders with moved children, as having new local structure.

Merging now produces a sequence of completion operations, instead of
raw merged descendants. Completion ops describe how to update the local
tree so that it matches the remote tree. These include changing GUIDs,
taking remote items, applying new structure, and updating change
counters. We try to avoid emitting completion ops for items that didn't
change (like children of a folder with new local structure that have
the same positions) to avoid unnecessary database work. The name
""completion ops"" comes from Firefox for iOS, which had a similar
concept in its old bookmark sync implementation.

Additionally, the ""unchanged"" merge state really means unchanged now.
Before, it meant something like ""unchanged, possibly with new
children"". ""Unchanged with new local structure"" is a new state that's
used for roots, where we want to apply merged children, but not a
synced root's title. We compare child GUIDs to determine if a folder's
local and remote children are unchanged, and use a new
`merge_unchanged_child_into_merged_node` method that skips checking for
moved children.

Finally, we now check validity when determining which side to take, and
pick the valid side even if it's unchanged or older.

Closes #46.",linacambridge,41387967,2019-07-17T17:49:30Z,CONTRIBUTOR,True,1240,666,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,e9d1f0fcdf566b3faeb43094537043272456ed08,Fix up some doc comments.
40,https://api.github.com/repos/mozilla/dogear/pulls/43,43,Emit telemetry events after each operation,"This commit adds a `Driver::record_telemetry_event` method that's
called with timings and counts after each store operation, instead
of returning a `Stats` struct at the end. This lets consumers like
Desktop record telemetry for interrupted or failed merges, and track
progress so we can see why some merges cause shutdown hangs.

https://bugzilla.mozilla.org/show_bug.cgi?id=1552621 has more details.",linacambridge,41387967,2019-05-21T04:47:46Z,CONTRIBUTOR,True,90,67,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,d4957a89e9935532f715fbe9ff36706be72b9ada,"Emit telemetry events after each operation.

This commit adds a `Driver::record_telemetry_event` method that's
called with timings and counts after each store operation, instead
of returning a `Stats` struct at the end. This lets consumers like
Desktop record telemetry for interrupted or failed merges, and track
progress so we can see why some merges cause shutdown hangs."
41,https://api.github.com/repos/mozilla/dogear/pulls/42,42,Make merges abortable,"This commit adds an `AbortSignal` trait that Desktop and Rust Places can use to interrupt merging, and adds calls to `err_if_aborted` in tight loops—and before each `Store` method.

It's identical to the [`Interruptee`](https://github.com/mozilla/application-services/blob/377c1580deb21b9e17f8ba6d36e2565bab0891a5/components/support/interrupt/src/lib.rs) trait from a-s.",linacambridge,41387967,2019-05-13T22:31:12Z,CONTRIBUTOR,True,110,31,6,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,2f87a26a9dbdd842ef65c12f19d5a25a5061ab03,"Make merges abortable.

This commit adds an `AbortSignal` trait that Desktop and Rust Places
can use to interrupt merging."
42,https://api.github.com/repos/mozilla/dogear/pulls/41,41,Add `Problems::counts()`,"This is similar to `getSummary` on Desktop: it returns the total count for each problem, and we can use the counts to report problems via telemetry.",linacambridge,41387967,2019-05-07T06:31:51Z,CONTRIBUTOR,True,173,6,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,9be09ab647fb83e53d46fa2fc8ca3074310ce789,"Add `Problems::counts()`.

These counts are used to report tree structure problems via telemetry."
43,https://api.github.com/repos/mozilla/dogear/pulls/40,40,Use Box<str> for Guid,"While I was here, figured I'd do this. I also noticed we're doing a bit more work than we have to when comparing Guids.

From `dbg!(std::mem::size_of::<Guid>())`

Before: `[src/guid.rs:269] std::mem::size_of::<Guid>() = 32`
After: `[src/guid.rs:269] std::mem::size_of::<Guid>() = 24`

Probably doesn't matter on 32 bit targets, but I haven't checked because it's more annoying to do so.",thomcc,860665,2019-04-26T17:49:53Z,CONTRIBUTOR,True,4,4,1,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,1f1c5a2c89c85e4912e9087a104bf00fd78eeb25,"Use Box<str> instead of String for invalid guids, reducing mem::size_of::<Guid>"
44,https://api.github.com/repos/mozilla/dogear/pulls/40,40,Use Box<str> for Guid,"While I was here, figured I'd do this. I also noticed we're doing a bit more work than we have to when comparing Guids.

From `dbg!(std::mem::size_of::<Guid>())`

Before: `[src/guid.rs:269] std::mem::size_of::<Guid>() = 32`
After: `[src/guid.rs:269] std::mem::size_of::<Guid>() = 24`

Probably doesn't matter on 32 bit targets, but I haven't checked because it's more annoying to do so.",thomcc,860665,2019-04-26T17:49:53Z,CONTRIBUTOR,True,4,4,1,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,6997665256a662118a2c1e8adc28a7669f0149eb,"Don't convert Guid to str when comparing with str

This skips pointlessly UTF-8 validating the GUID bytes."
45,https://api.github.com/repos/mozilla/dogear/pulls/39,39,Replace IntoTree with TryFrom/TryInto. Fixes #38,"Felt like doing this.

Note: It's a breaking change to remove IntoTree.",thomcc,860665,2019-04-26T17:36:12Z,CONTRIBUTOR,True,65,47,3,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,c272e19c53a9d590007cd6c4baedbf3e1f276218,Replace IntoTree with TryFrom/TryInto. Fixes #38
46,https://api.github.com/repos/mozilla/dogear/pulls/37,37,Treat livemarks as non-syncable on both sides,"Livemarks are no longer supported in Firefox, so let's delete them
from the tree entirely, on both sides. The bookmarks engine on Desktop
can export existing livemarks before a first sync, to avoid data loss.",linacambridge,41387967,2019-04-23T19:11:30Z,CONTRIBUTOR,True,87,37,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,0b5acdcf1a337e1a6cbb2d5919b2834b7036ed0e,"Treat livemarks as non-syncable on both sides.

Livemarks are no longer supported in Firefox, so let's delete them
from the tree entirely, on both sides. The bookmarks engine on Desktop
can export existing livemarks before a first sync, to avoid data loss."
47,https://api.github.com/repos/mozilla/dogear/pulls/37,37,Treat livemarks as non-syncable on both sides,"Livemarks are no longer supported in Firefox, so let's delete them
from the tree entirely, on both sides. The bookmarks engine on Desktop
can export existing livemarks before a first sync, to avoid data loss.",linacambridge,41387967,2019-04-23T19:11:30Z,CONTRIBUTOR,True,87,37,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,ddcdce459aeeba962779c229cb95bfbb5738fbf3,"Use `.map_or(X, Y)` instead of `.map(Y).unwrap_or(X)`."
48,https://api.github.com/repos/mozilla/dogear/pulls/37,37,Treat livemarks as non-syncable on both sides,"Livemarks are no longer supported in Firefox, so let's delete them
from the tree entirely, on both sides. The bookmarks engine on Desktop
can export existing livemarks before a first sync, to avoid data loss.",linacambridge,41387967,2019-04-23T19:11:30Z,CONTRIBUTOR,True,87,37,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,d7ba53a58e54b426b5db24e25c200b5ed792bcda,Fix up Clippy lints.
49,https://api.github.com/repos/mozilla/dogear/pulls/36,36,Enable the `rust_2018_idioms` lint,Why not? 😄,linacambridge,41387967,2019-04-16T18:42:05Z,CONTRIBUTOR,True,34,31,6,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,61321751f12a56521c325de3fab14e6d88dac2dc,Enable the `rust_2018_idioms` lint.
50,https://api.github.com/repos/mozilla/dogear/pulls/35,35,"Use `Cow<'t, Guid>` for most GUIDs","Valid GUIDs are cheap to clone, but we can avoid even that, since a `Merger` (and the merged nodes it returns) can't outlive the trees it's merging.

Mooo! 🐮",linacambridge,41387967,2019-04-07T21:45:25Z,CONTRIBUTOR,False,81,48,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,9db2301fd49e8f3175d4dad756ef90890d63abba,"Use `Cow<'t, Guid>` for most GUIDs. 🐮

Valid GUIDs are cheap to clone, but we can avoid even that, since a
`Merger` (and the merged nodes it returns) can't outlive the trees
it's merging."
51,https://api.github.com/repos/mozilla/dogear/pulls/34,34,Fixes for handling invalid items,"There are a few cases I missed...

* An item that's invalid on one side and doesn't exist on the other. (We handled the case where it was _explicitly deleted_, but not where it didn't exist at all).
* If an item is changed on one or both sides, and invalid on the other, we should always pick the other side. (`check_for_{remote, local}_structure_changes_of_{local, remote}_node` takes care of deleting them if they're invalid on both).",linacambridge,41387967,2019-04-01T21:54:15Z,CONTRIBUTOR,True,229,145,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,17643f2bdcd26e303c0d76bd897e92debbef5959,Derive `Copy` and `Hash` for `StructureCounts` and `Deletion`.
52,https://api.github.com/repos/mozilla/dogear/pulls/34,34,Fixes for handling invalid items,"There are a few cases I missed...

* An item that's invalid on one side and doesn't exist on the other. (We handled the case where it was _explicitly deleted_, but not where it didn't exist at all).
* If an item is changed on one or both sides, and invalid on the other, we should always pick the other side. (`check_for_{remote, local}_structure_changes_of_{local, remote}_node` takes care of deleting them if they're invalid on both).",linacambridge,41387967,2019-04-01T21:54:15Z,CONTRIBUTOR,True,229,145,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,f912e8b937a53f74734e6ecac1997f7b930a5fbe,"Don't take invalid item changes, even if they're newer.

`resolve_value_conflict` should only compare timestamps if the items
are valid on both sides. If not, pick the other side."
53,https://api.github.com/repos/mozilla/dogear/pulls/34,34,Fixes for handling invalid items,"There are a few cases I missed...

* An item that's invalid on one side and doesn't exist on the other. (We handled the case where it was _explicitly deleted_, but not where it didn't exist at all).
* If an item is changed on one or both sides, and invalid on the other, we should always pick the other side. (`check_for_{remote, local}_structure_changes_of_{local, remote}_node` takes care of deleting them if they're invalid on both).",linacambridge,41387967,2019-04-01T21:54:15Z,CONTRIBUTOR,True,229,145,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,edbc09e24312685a6a7fd86923859abad3e27751,"Delete items that are invalid on one side and don't exist on the other.

We handled ""invalid on one side, deleted on the other"", but not the
case where the item doesn't exist on the other side at all. This commit
also adds test coverage, renames
`relocate_{local, remote}_orphans_to_merged_node` to
`delete_{local, remote}_node`, and simplifies
`check_for_{local, remote}_structure_change_of_{remote, local}_node`."
54,https://api.github.com/repos/mozilla/dogear/pulls/33,33,Record and report why the structure diverged for logging and validation,"This PR refactors how we resolve diverging structure, and adds a way to report those problems. The diff is pretty big; it's easier to follow the individual commits, which I've tried to break up into reviewable chunks.

The reports are most useful for logging, so we can see why Dogear decided something diverged. Right now, there's no way to tell without examining the DB before a sync, or looking at the server records in About Sync.

We could even turn on debug (trace has PII concerns) and success logging for _just this sync_ if we detect problems. That way, when folks notice issues, they can hopefully upload more complete logs...we wouldn't need to ask them to try to reproduce. We could also explore automated log collection; maybe in Rust Places via Sentry? Though, again, we'd need to make sure there's no PII.

Also, we could use this problem data to report validation errors, like we do on Desktop! It doesn't report non-structure differences...but, since we already have the complete structure, we're already effectively validating before each sync, anyway.

(I think an independent validator in About Sync is still useful—what if Dogear's validator has bugs, or there's a bug in how we fetch or store the tree structure in the DB? Who watches the watcher? 😆 But this might be a better approach for bookmark validation on mobile).

I've also tried to add comments where they make sense, because I don't want Dogear to be write-only. :joy: Let me know if there's anything unclear, or if there are obvious comments that I can remove!",linacambridge,41387967,2019-03-30T23:01:44Z,CONTRIBUTOR,True,670,264,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,ba4f1172a3f39cb31c44ac83ede2f29338022a2a,"Factor out resolving possible parents into `PossibleParents`.

The logic for breaking the tie between conflicting parents is hard to
digest when it's inlined into `resolve`. Instead of using `min_by()`,
we can iterate over a sequence of `PossibleParent`s that implement
the logic as part of `Ord::cmp`.

This commit also adds more comments that explain how we pick the
parent."
55,https://api.github.com/repos/mozilla/dogear/pulls/33,33,Record and report why the structure diverged for logging and validation,"This PR refactors how we resolve diverging structure, and adds a way to report those problems. The diff is pretty big; it's easier to follow the individual commits, which I've tried to break up into reviewable chunks.

The reports are most useful for logging, so we can see why Dogear decided something diverged. Right now, there's no way to tell without examining the DB before a sync, or looking at the server records in About Sync.

We could even turn on debug (trace has PII concerns) and success logging for _just this sync_ if we detect problems. That way, when folks notice issues, they can hopefully upload more complete logs...we wouldn't need to ask them to try to reproduce. We could also explore automated log collection; maybe in Rust Places via Sentry? Though, again, we'd need to make sure there's no PII.

Also, we could use this problem data to report validation errors, like we do on Desktop! It doesn't report non-structure differences...but, since we already have the complete structure, we're already effectively validating before each sync, anyway.

(I think an independent validator in About Sync is still useful—what if Dogear's validator has bugs, or there's a bug in how we fetch or store the tree structure in the DB? Who watches the watcher? 😆 But this might be a better approach for bookmark validation on mobile).

I've also tried to add comments where they make sense, because I don't want Dogear to be write-only. :joy: Let me know if there's anything unclear, or if there are obvious comments that I can remove!",linacambridge,41387967,2019-03-30T23:01:44Z,CONTRIBUTOR,True,670,264,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,80c26a08244e5681de58eb3432b069080327a9d5,"Factor out parent resolution into `ResolveParent`.

This builds on the last commit. The algorithm for resolving parents
is hard to follow when it's inlined into `Builder::resolve`, isn't
as efficient as it could be for roots, isn't well-commented, and
tolerates unreachable cases.

This commit factors that logic out into a separate `ResolveParent`
type. It simplifies how we handle complete and partial parents,
unrolls the nested iterator chains in `Builder::into_tree`,
tightens up some cases, and adds more docs."
56,https://api.github.com/repos/mozilla/dogear/pulls/33,33,Record and report why the structure diverged for logging and validation,"This PR refactors how we resolve diverging structure, and adds a way to report those problems. The diff is pretty big; it's easier to follow the individual commits, which I've tried to break up into reviewable chunks.

The reports are most useful for logging, so we can see why Dogear decided something diverged. Right now, there's no way to tell without examining the DB before a sync, or looking at the server records in About Sync.

We could even turn on debug (trace has PII concerns) and success logging for _just this sync_ if we detect problems. That way, when folks notice issues, they can hopefully upload more complete logs...we wouldn't need to ask them to try to reproduce. We could also explore automated log collection; maybe in Rust Places via Sentry? Though, again, we'd need to make sure there's no PII.

Also, we could use this problem data to report validation errors, like we do on Desktop! It doesn't report non-structure differences...but, since we already have the complete structure, we're already effectively validating before each sync, anyway.

(I think an independent validator in About Sync is still useful—what if Dogear's validator has bugs, or there's a bug in how we fetch or store the tree structure in the DB? Who watches the watcher? 😆 But this might be a better approach for bookmark validation on mobile).

I've also tried to add comments where they make sense, because I don't want Dogear to be write-only. :joy: Let me know if there's anything unclear, or if there are obvious comments that I can remove!",linacambridge,41387967,2019-03-30T23:01:44Z,CONTRIBUTOR,True,670,264,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,9e3e482f46c4d925d4951a7116481dd5a606a25b,"Record and report problems with tree structure.

This commit records problems that Dogear notices when building a
tree, and outputs a summary when the tree is printed. It's useful for
logging, so we can see why the structure diverged.

We can also use it to emit validation events, like the Desktop Sync
ping, if we decide to in the future."
57,https://api.github.com/repos/mozilla/dogear/pulls/33,33,Record and report why the structure diverged for logging and validation,"This PR refactors how we resolve diverging structure, and adds a way to report those problems. The diff is pretty big; it's easier to follow the individual commits, which I've tried to break up into reviewable chunks.

The reports are most useful for logging, so we can see why Dogear decided something diverged. Right now, there's no way to tell without examining the DB before a sync, or looking at the server records in About Sync.

We could even turn on debug (trace has PII concerns) and success logging for _just this sync_ if we detect problems. That way, when folks notice issues, they can hopefully upload more complete logs...we wouldn't need to ask them to try to reproduce. We could also explore automated log collection; maybe in Rust Places via Sentry? Though, again, we'd need to make sure there's no PII.

Also, we could use this problem data to report validation errors, like we do on Desktop! It doesn't report non-structure differences...but, since we already have the complete structure, we're already effectively validating before each sync, anyway.

(I think an independent validator in About Sync is still useful—what if Dogear's validator has bugs, or there's a bug in how we fetch or store the tree structure in the DB? Who watches the watcher? 😆 But this might be a better approach for bookmark validation on mobile).

I've also tried to add comments where they make sense, because I don't want Dogear to be write-only. :joy: Let me know if there's anything unclear, or if there are obvious comments that I can remove!",linacambridge,41387967,2019-03-30T23:01:44Z,CONTRIBUTOR,True,670,264,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,3563c70f3bf4a6641d457347083dc081811a5f0a,"Improve problem summaries.

* Split `MultipleParents`, `{Missing, NonFolder}ParentGuid`, and
  `ParentChildDisagreement` into `DivergedParent::By{Guid,
  ParentGuid}`, and add `DivergedParentGuid` to distinguish
  between folders, non-folders, and nonexistent parents. This matches
  how the builder stores parents internally, and makes for more
  accurate messages.
* Use named fields in `Problem` variants for clarity.
* Return more readable summary strings."
58,https://api.github.com/repos/mozilla/dogear/pulls/33,33,Record and report why the structure diverged for logging and validation,"This PR refactors how we resolve diverging structure, and adds a way to report those problems. The diff is pretty big; it's easier to follow the individual commits, which I've tried to break up into reviewable chunks.

The reports are most useful for logging, so we can see why Dogear decided something diverged. Right now, there's no way to tell without examining the DB before a sync, or looking at the server records in About Sync.

We could even turn on debug (trace has PII concerns) and success logging for _just this sync_ if we detect problems. That way, when folks notice issues, they can hopefully upload more complete logs...we wouldn't need to ask them to try to reproduce. We could also explore automated log collection; maybe in Rust Places via Sentry? Though, again, we'd need to make sure there's no PII.

Also, we could use this problem data to report validation errors, like we do on Desktop! It doesn't report non-structure differences...but, since we already have the complete structure, we're already effectively validating before each sync, anyway.

(I think an independent validator in About Sync is still useful—what if Dogear's validator has bugs, or there's a bug in how we fetch or store the tree structure in the DB? Who watches the watcher? 😆 But this might be a better approach for bookmark validation on mobile).

I've also tried to add comments where they make sense, because I don't want Dogear to be write-only. :joy: Let me know if there's anything unclear, or if there are obvious comments that I can remove!",linacambridge,41387967,2019-03-30T23:01:44Z,CONTRIBUTOR,True,670,264,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,27fa8dcb10e7d14bd2025d3321781580dd24f658,Add more struct and method docs.
59,https://api.github.com/repos/mozilla/dogear/pulls/33,33,Record and report why the structure diverged for logging and validation,"This PR refactors how we resolve diverging structure, and adds a way to report those problems. The diff is pretty big; it's easier to follow the individual commits, which I've tried to break up into reviewable chunks.

The reports are most useful for logging, so we can see why Dogear decided something diverged. Right now, there's no way to tell without examining the DB before a sync, or looking at the server records in About Sync.

We could even turn on debug (trace has PII concerns) and success logging for _just this sync_ if we detect problems. That way, when folks notice issues, they can hopefully upload more complete logs...we wouldn't need to ask them to try to reproduce. We could also explore automated log collection; maybe in Rust Places via Sentry? Though, again, we'd need to make sure there's no PII.

Also, we could use this problem data to report validation errors, like we do on Desktop! It doesn't report non-structure differences...but, since we already have the complete structure, we're already effectively validating before each sync, anyway.

(I think an independent validator in About Sync is still useful—what if Dogear's validator has bugs, or there's a bug in how we fetch or store the tree structure in the DB? Who watches the watcher? 😆 But this might be a better approach for bookmark validation on mobile).

I've also tried to add comments where they make sense, because I don't want Dogear to be write-only. :joy: Let me know if there's anything unclear, or if there are obvious comments that I can remove!",linacambridge,41387967,2019-03-30T23:01:44Z,CONTRIBUTOR,True,670,264,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,25adb650c1d7126bfa4dd885c21dae7179d85448,Only allow `ByParentGuid` overrides for reparented roots.
60,https://api.github.com/repos/mozilla/dogear/pulls/31,31,Add a book!,"[mdBook](https://rust-lang-nursery.github.io/mdBook/) makes this delightfully easy. Still needs better docs for the merge algo, `Store::apply`, and how everything fits together, but it's a start.

Closes #24.",linacambridge,41387967,2019-03-19T06:21:17Z,CONTRIBUTOR,True,399,4,13,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,1e1781ac150b403368552a7309cebba009cec2c3,"First draft of the docs.

This commit adds an mdBook skeleton that covers building the trees,
divergences, deduping, and implementing `Store`. It also explains the
merge algorithm at a high level.

Still needed: application, putting everything together, a more
detailed explanation of the algo.

Closes #24."
61,https://api.github.com/repos/mozilla/dogear/pulls/31,31,Add a book!,"[mdBook](https://rust-lang-nursery.github.io/mdBook/) makes this delightfully easy. Still needs better docs for the merge algo, `Store::apply`, and how everything fits together, but it's a start.

Closes #24.",linacambridge,41387967,2019-03-19T06:21:17Z,CONTRIBUTOR,True,399,4,13,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,c67b4906572900a8e22277365b5099ce9e05e726,Build the book on Travis.
62,https://api.github.com/repos/mozilla/dogear/pulls/30,30,Re-add the `log` crate for logging,"On Slack, @mhammond suggested using `log::Level` instead of rolling
our own. It turns out that `log` exposes all the building blocks for
logging messages, too, so we can have `Driver` return an implementation
of `log::Log` instead of handling logging ourselves.

The default implementation returns the global logger, so things will
""just work"" in Rust Places. On Desktop, we'll have `XpComLogger`
implement `log::Log`, and return that instead of the global one.

See #20.",linacambridge,41387967,2019-03-19T04:34:36Z,CONTRIBUTOR,True,101,28,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,83efa18b92acbb1c29bec690c5a55856e50fe0b8,"Re-add the `log` crate for logging.

On Slack, @mhammond suggested using `log::Level` instead of rolling
our own. It turns out that `log` exposes all the building blocks for
logging messages, too, so we can have `Driver` return an implementation
of `log::Log` instead of handling logging ourselves.

The default implementation returns the global logger, so things will
""just work"" in Rust Places. On Desktop, we'll have `XpComLogger`
implement `log::Log`, and return that instead of the global one.

See #20."
63,https://api.github.com/repos/mozilla/dogear/pulls/30,30,Re-add the `log` crate for logging,"On Slack, @mhammond suggested using `log::Level` instead of rolling
our own. It turns out that `log` exposes all the building blocks for
logging messages, too, so we can have `Driver` return an implementation
of `log::Log` instead of handling logging ourselves.

The default implementation returns the global logger, so things will
""just work"" in Rust Places. On Desktop, we'll have `XpComLogger`
implement `log::Log`, and return that instead of the global one.

See #20.",linacambridge,41387967,2019-03-19T04:34:36Z,CONTRIBUTOR,True,101,28,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,200e186dfae294f661178d0ac84b927467caeffb,"Expose `Driver::max_log_level()`.

Also, don't flush after every log message."
64,https://api.github.com/repos/mozilla/dogear/pulls/30,30,Re-add the `log` crate for logging,"On Slack, @mhammond suggested using `log::Level` instead of rolling
our own. It turns out that `log` exposes all the building blocks for
logging messages, too, so we can have `Driver` return an implementation
of `log::Log` instead of handling logging ourselves.

The default implementation returns the global logger, so things will
""just work"" in Rust Places. On Desktop, we'll have `XpComLogger`
implement `log::Log`, and return that instead of the global one.

See #20.",linacambridge,41387967,2019-03-19T04:34:36Z,CONTRIBUTOR,True,101,28,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,0ec64209ac5412e615ba5cec73eca469e3f59734,Factor out the shared logging logic into a function.
65,https://api.github.com/repos/mozilla/dogear/pulls/30,30,Re-add the `log` crate for logging,"On Slack, @mhammond suggested using `log::Level` instead of rolling
our own. It turns out that `log` exposes all the building blocks for
logging messages, too, so we can have `Driver` return an implementation
of `log::Log` instead of handling logging ourselves.

The default implementation returns the global logger, so things will
""just work"" in Rust Places. On Desktop, we'll have `XpComLogger`
implement `log::Log`, and return that instead of the global one.

See #20.",linacambridge,41387967,2019-03-19T04:34:36Z,CONTRIBUTOR,True,101,28,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,2be2547f585fd808833498d801484ad6928401b5,Change `Driver::logger` to return `&dyn Log`.
66,https://api.github.com/repos/mozilla/dogear/pulls/28,28,Add an `UploadReason` for merged descendants,"We'll use this on Desktop to track sync loops, where two or more
clients reupload the same record on every sync, even though the
user hasn't changed it locally.

The idea is: on every sync, we'll store the GUIDs of all uploaded items
in a separate table, along with the timestamp and reason. If we see a
GUID uploaded with `NewStructure` for 5-ish consecutive syncs, we'll
emit telemetry.",linacambridge,41387967,2019-02-23T22:44:17Z,CONTRIBUTOR,True,42,12,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,ef2479be937b7d470428d7c0dc91a63a97566ff6,"Add an `UploadReason` for merged descendants.

We'll use this on Desktop to track sync loops, where two or more
clients reupload the same record on every sync, even though the
user hasn't changed it locally.

The idea is: on every sync, we'll store the GUIDs of all uploaded items
in a separate table, along with the timestamp and reason. If we see a
GUID uploaded with `NewStructure` for 5-ish consecutive syncs, we'll
emit telemetry."
67,https://api.github.com/repos/mozilla/dogear/pulls/27,27,Clarify and add tests for GUID changing,"As promised. 😄  This also takes the good parts of #26 (checking for dupes, changing GUIDs for nodes on both sides, and comments for what we reupload and why).",linacambridge,41387967,2019-02-23T22:09:24Z,CONTRIBUTOR,True,157,84,3,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,b009d467e02b47e303d47417b9e44e9c344da6e8,"Clarify the merging behavior for changed GUIDs.

* If the merged parent's GUID changed, we need to flag its children for
  reupload, so that the childrens' `parentid` is correct.
* If the merged child's GUID changed, we need to flag its parent for
  reupload, so that the parent's `children` are correct.
* It's an error for `Driver::generate_new_guid` to return a GUID that we
  already merged."
68,https://api.github.com/repos/mozilla/dogear/pulls/27,27,Clarify and add tests for GUID changing,"As promised. 😄  This also takes the good parts of #26 (checking for dupes, changing GUIDs for nodes on both sides, and comments for what we reupload and why).",linacambridge,41387967,2019-02-23T22:09:24Z,CONTRIBUTOR,True,157,84,3,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,0f6256e7adea2a9cbbc1ef2c85c9c2ea217c26ad,"Rename `Guid::{Fast, Slow}` to `Guid::{Valid, Invalid}`."
69,https://api.github.com/repos/mozilla/dogear/pulls/27,27,Clarify and add tests for GUID changing,"As promised. 😄  This also takes the good parts of #26 (checking for dupes, changing GUIDs for nodes on both sides, and comments for what we reupload and why).",linacambridge,41387967,2019-02-23T22:09:24Z,CONTRIBUTOR,True,157,84,3,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,4c81c818cbc594e7092bea38f2bd1fa5de08b953,Add a merger test for changing invalid GUIDs.
70,https://api.github.com/repos/mozilla/dogear/pulls/26,26,Keep both local and remote nodes with mismatched kinds,"For mismatched kinds, we keep both nodes with new GUIDs. This is an
edge case: Places maintenance on Desktop can change an item's
kind without changing its GUID, but this should be rare.

In general, we can't meaningfully pick a side when two items have
different kinds (a bookmark and a folder with children? a bookmark and
a separator?), so we keep both, with new structure, to avoid possible
data loss.

See #13.",linacambridge,41387967,2019-02-17T07:57:43Z,CONTRIBUTOR,False,1002,351,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,3252307d8c2a704702e9829245a02ba9e23a2f6f,"Add `MergedNode::descendants()`.

This returns an iterator that yields the merged node's descendants, in
level order."
71,https://api.github.com/repos/mozilla/dogear/pulls/26,26,Keep both local and remote nodes with mismatched kinds,"For mismatched kinds, we keep both nodes with new GUIDs. This is an
edge case: Places maintenance on Desktop can change an item's
kind without changing its GUID, but this should be rare.

In general, we can't meaningfully pick a side when two items have
different kinds (a bookmark and a folder with children? a bookmark and
a separator?), so we keep both, with new structure, to avoid possible
data loss.

See #13.",linacambridge,41387967,2019-02-17T07:57:43Z,CONTRIBUTOR,False,1002,351,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,16a0cb2fc9f118084303e6861f8e83fc1ef8c8e5,"Add `{Local, Remote}Only` merge states; remove `LocalWithNewStructure`.

Before `Unchanged`, `Local` meant ""keep local and maybe upload"", and
`LocalWithNewStructure` meant ""keep local and always upload"". Now
that `Unchanged` exists, `Local` means ""keep local and upload"", so
`LocalWithNewStructure` is redundant.

Further, it wasn't obvious that `Local { remote_node: None }` meant
the item only exists locally, and should be uploaded unconditionally,
and `Remote { local_node: None }` meant the item only exists remotely,
and should be applied unconditionally. This commit changes `Local`
and `Remote` to mean ""exists on both sides, but prefer one"", and adds
`LocalOnly`, `RemoteOnly`, and `RemoteOnlyWithNewStructure` to mean
""exists on one side, so take unconditionally"".

To that end, this commit treats remotely changed user content roots as
`Unchanged`. As of bug 1432614, roots don't have user-editable titles,
so applying remote title changes is unnecessary. However, we also don't
mark the roots as `Local`, because that would mean we'd reupload the
root _every time_ it was changed remotely.

Finally, we want callers to easily determine whether to apply remote
changes, and upload local and new changes. This commit adds
`MergeState::{should_apply, should_upload}()` for that."
72,https://api.github.com/repos/mozilla/dogear/pulls/26,26,Keep both local and remote nodes with mismatched kinds,"For mismatched kinds, we keep both nodes with new GUIDs. This is an
edge case: Places maintenance on Desktop can change an item's
kind without changing its GUID, but this should be rare.

In general, we can't meaningfully pick a side when two items have
different kinds (a bookmark and a folder with children? a bookmark and
a separator?), so we keep both, with new structure, to avoid possible
data loss.

See #13.",linacambridge,41387967,2019-02-17T07:57:43Z,CONTRIBUTOR,False,1002,351,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,395b86b3084479450288164cdb93668a8dbebafb,Add docs and `inline` attributes to tree methods.
73,https://api.github.com/repos/mozilla/dogear/pulls/26,26,Keep both local and remote nodes with mismatched kinds,"For mismatched kinds, we keep both nodes with new GUIDs. This is an
edge case: Places maintenance on Desktop can change an item's
kind without changing its GUID, but this should be rare.

In general, we can't meaningfully pick a side when two items have
different kinds (a bookmark and a folder with children? a bookmark and
a separator?), so we keep both, with new structure, to avoid possible
data loss.

See #13.",linacambridge,41387967,2019-02-17T07:57:43Z,CONTRIBUTOR,False,1002,351,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,69c9cd0c894659e5870d42de54bf07ef701b0e5e,Add a `guid::IsValid` trait for `Guid`s and byte slices.
74,https://api.github.com/repos/mozilla/dogear/pulls/26,26,Keep both local and remote nodes with mismatched kinds,"For mismatched kinds, we keep both nodes with new GUIDs. This is an
edge case: Places maintenance on Desktop can change an item's
kind without changing its GUID, but this should be rare.

In general, we can't meaningfully pick a side when two items have
different kinds (a bookmark and a folder with children? a bookmark and
a separator?), so we keep both, with new structure, to avoid possible
data loss.

See #13.",linacambridge,41387967,2019-02-17T07:57:43Z,CONTRIBUTOR,False,1002,351,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,1986fed809f360e089eb1017be0a0cd6a19c2b61,Don't allow roots to be moved or deleted.
75,https://api.github.com/repos/mozilla/dogear/pulls/26,26,Keep both local and remote nodes with mismatched kinds,"For mismatched kinds, we keep both nodes with new GUIDs. This is an
edge case: Places maintenance on Desktop can change an item's
kind without changing its GUID, but this should be rare.

In general, we can't meaningfully pick a side when two items have
different kinds (a bookmark and a folder with children? a bookmark and
a separator?), so we keep both, with new structure, to avoid possible
data loss.

See #13.",linacambridge,41387967,2019-02-17T07:57:43Z,CONTRIBUTOR,False,1002,351,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,c54538bcc517eca3c6711f68c4023d950a35b85a,"Track item validity states and flag invalid items for reupload.

This ports the merger parts of
https://bugzilla.mozilla.org/show_bug.cgi?id=1515784."
76,https://api.github.com/repos/mozilla/dogear/pulls/26,26,Keep both local and remote nodes with mismatched kinds,"For mismatched kinds, we keep both nodes with new GUIDs. This is an
edge case: Places maintenance on Desktop can change an item's
kind without changing its GUID, but this should be rare.

In general, we can't meaningfully pick a side when two items have
different kinds (a bookmark and a folder with children? a bookmark and
a separator?), so we keep both, with new structure, to avoid possible
data loss.

See #13.",linacambridge,41387967,2019-02-17T07:57:43Z,CONTRIBUTOR,False,1002,351,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,30e14a443b4d6fa529d002c2f1d290684fd3417e,Compare timestamps instead of taking the other side for diverged items.
77,https://api.github.com/repos/mozilla/dogear/pulls/26,26,Keep both local and remote nodes with mismatched kinds,"For mismatched kinds, we keep both nodes with new GUIDs. This is an
edge case: Places maintenance on Desktop can change an item's
kind without changing its GUID, but this should be rare.

In general, we can't meaningfully pick a side when two items have
different kinds (a bookmark and a folder with children? a bookmark and
a separator?), so we keep both, with new structure, to avoid possible
data loss.

See #13.",linacambridge,41387967,2019-02-17T07:57:43Z,CONTRIBUTOR,False,1002,351,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,5fffe4b7b8c81c4e1eb841fe908e41dc8c3156ea,Rename `guid::IsValid` to `guid::IsValidGuid`.
78,https://api.github.com/repos/mozilla/dogear/pulls/26,26,Keep both local and remote nodes with mismatched kinds,"For mismatched kinds, we keep both nodes with new GUIDs. This is an
edge case: Places maintenance on Desktop can change an item's
kind without changing its GUID, but this should be rare.

In general, we can't meaningfully pick a side when two items have
different kinds (a bookmark and a folder with children? a bookmark and
a separator?), so we keep both, with new structure, to avoid possible
data loss.

See #13.",linacambridge,41387967,2019-02-17T07:57:43Z,CONTRIBUTOR,False,1002,351,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,ece9d315b1402cbd41f2b76c1ab5d34559cdb4cf,Ignore `Repr` when comparing and hashing GUIDs.
79,https://api.github.com/repos/mozilla/dogear/pulls/26,26,Keep both local and remote nodes with mismatched kinds,"For mismatched kinds, we keep both nodes with new GUIDs. This is an
edge case: Places maintenance on Desktop can change an item's
kind without changing its GUID, but this should be rare.

In general, we can't meaningfully pick a side when two items have
different kinds (a bookmark and a folder with children? a bookmark and
a separator?), so we keep both, with new structure, to avoid possible
data loss.

See #13.",linacambridge,41387967,2019-02-17T07:57:43Z,CONTRIBUTOR,False,1002,351,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,eeec5ba8405f401607d3ebc18e26545572dcc84f,Collect descendants and deletions instead of returning an iterator.
80,https://api.github.com/repos/mozilla/dogear/pulls/26,26,Keep both local and remote nodes with mismatched kinds,"For mismatched kinds, we keep both nodes with new GUIDs. This is an
edge case: Places maintenance on Desktop can change an item's
kind without changing its GUID, but this should be rare.

In general, we can't meaningfully pick a side when two items have
different kinds (a bookmark and a folder with children? a bookmark and
a separator?), so we keep both, with new structure, to avoid possible
data loss.

See #13.",linacambridge,41387967,2019-02-17T07:57:43Z,CONTRIBUTOR,False,1002,351,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,776579ca037efb3d814d2a14ed3b3f31419f38c0,Log merged local and remote deletions.
81,https://api.github.com/repos/mozilla/dogear/pulls/26,26,Keep both local and remote nodes with mismatched kinds,"For mismatched kinds, we keep both nodes with new GUIDs. This is an
edge case: Places maintenance on Desktop can change an item's
kind without changing its GUID, but this should be rare.

In general, we can't meaningfully pick a side when two items have
different kinds (a bookmark and a folder with children? a bookmark and
a separator?), so we keep both, with new structure, to avoid possible
data loss.

See #13.",linacambridge,41387967,2019-02-17T07:57:43Z,CONTRIBUTOR,False,1002,351,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,91124bffad09a09f6a678128ea16d16bf7668b26,Treat remote livemarks and diverged queries as non-syncable.
82,https://api.github.com/repos/mozilla/dogear/pulls/26,26,Keep both local and remote nodes with mismatched kinds,"For mismatched kinds, we keep both nodes with new GUIDs. This is an
edge case: Places maintenance on Desktop can change an item's
kind without changing its GUID, but this should be rare.

In general, we can't meaningfully pick a side when two items have
different kinds (a bookmark and a folder with children? a bookmark and
a separator?), so we keep both, with new structure, to avoid possible
data loss.

See #13.",linacambridge,41387967,2019-02-17T07:57:43Z,CONTRIBUTOR,False,1002,351,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,b2410ff5f5b164b61d0136329067a50c34164f47,"Keep both local and remote nodes with mismatched kinds.

For mismatched kinds, we keep both nodes with new GUIDs. This is an
edge case: Places maintenance on Desktop can change an item's
kind without changing its GUID, but this should be rare.

In general, we can't meaningfully pick a side when two items have
different kinds (a bookmark and a folder with children? a bookmark and
a separator?), so we keep both, with new structure, to avoid possible
data loss.

See #13."
83,https://api.github.com/repos/mozilla/dogear/pulls/25,25,Collect telemetry stats,This adds a simple recorder for timings and counts.,linacambridge,41387967,2019-02-17T07:53:41Z,CONTRIBUTOR,True,256,105,6,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,96f4afaf6f8be1a671183087a65e47464fc6d731,Collect timings and counters for telemetry.
84,https://api.github.com/repos/mozilla/dogear/pulls/25,25,Collect telemetry stats,This adds a simple recorder for timings and counts.,linacambridge,41387967,2019-02-17T07:53:41Z,CONTRIBUTOR,True,256,105,6,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,21a11a414b12456557715e882f4e53b9feafd448,Derive more `LogLevel` traits and clean up log macros.
85,https://api.github.com/repos/mozilla/dogear/pulls/25,25,Collect telemetry stats,This adds a simple recorder for timings and counts.,linacambridge,41387967,2019-02-17T07:53:41Z,CONTRIBUTOR,True,256,105,6,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,9a317f0314023fed8a4731630776248984cecf7b,"Replace `Stats` with a struct returned from `Store::merge`.

Since we already tracked most of our counts in `StructureCounts`, this
commit adds `merged_nodes` and `merged_deletions`. Bonus: counting
merged nodes this way lets us preallocate the space we need to hold all
the descendants when we recurse down the merged root.

This also adds a `MergedTimings` struct, and a macro for recording
timings with operation names."
86,https://api.github.com/repos/mozilla/dogear/pulls/23,23,Replant the tree! 🌲,"This started out as a fix for corruption corner cases, grew into
simplifying how we build the remote tree, and turned into a rewrite
(again >.>). Instead of managing two different sets of structure at
insert and merge time, we now store items and parent-child
relationships in a tree builder, then build a consistent tree that
flags divergent items.

The old tree was complicated because it had to maintain a valid
structure before and after every insert, but with references to
potentially unknown parents and children. Since we couldn't insert
an item without knowing its parent, we had to pick a canonical
structure (parents by `children`), insert children in level
order, and note divergent structure (by `parentid`) separately.

This meant Desktop's `Store::fetch_remote_tree()` had to left-join
`mirror.items` to `mirror.structure`, store the items in a
pseudo-tree, then recursively walk children to inflate the complete
tree. This was complicated enough with a valid tree, let alone
orphans and multiple parents.

With the new approach, we build the tree in three steps:

1. First, we add all items, without structure.
2. Next, we set parent-child relationships. Parents by `children`
   require the parent to exist, but not the child; this handles the
   case where a folder mentions nonexistent or deleted GUIDs in
   its `children`. Parents by `parentid` require the item to exist,
   but not its parent; this handles orphans that reference missing
   or non-folder parents.
3. Finally, once we've added all entries to the tree, we have a
   complete view of the structure, so we can resolve missing, multiple,
   and conflicting parents.

For cases where we know the structure is valid and in level order,
like Desktop's `Store::fetch_local_tree()`, we handle steps 1 and 2
at the same time: `builder.item(item)?.by_structure(&parent_guid)?`.

For the remote tree, we insert all items and their `parentid`s
first (`builder.item(item)?.by_parent_guid(&parent_guid)?`, where
`parent_guid` might not be in the tree), then add structure from
children later:
`builder.parent_for(&child_guid)?.by_children(&parent_guid)?`,
where `child_guid` might not be in the tree.

Closes #22.",linacambridge,41387967,2019-02-13T01:42:25Z,CONTRIBUTOR,True,745,677,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,25266378ea73061481ac9409710ddeb9ad7a4844,"Replant the tree! 🌲

This started out as a fix for corruption corner cases, grew into
simplifying how we build the remote tree, and turned into a rewrite
(again >.>). Instead of managing two different sets of structure at
insert and merge time, we now store items and parent-child
relationships in a tree builder, then build a consistent tree that
flags divergent items.

The old tree was complicated because it had to maintain a valid
structure before and after every insert, but with references to
potentially unknown parents and children. Since we couldn't insert
an item without knowing its parent, we had to pick a canonical
structure (parents by `children`), insert children in level
order, and note divergent structure (by `parentid`) separately.

This meant Desktop's `Store::fetch_remote_tree()` had to left-join
`mirror.items` to `mirror.structure`, store the items in a
pseudo-tree, then recursively walk children to inflate the complete
tree. This was complicated enough with a valid tree, let alone
orphans and multiple parents.

With the new approach, we build the tree in three steps:

1. First, we add all items, without structure.
2. Next, we set parent-child relationships. Parents by `children`
   require the parent to exist, but not the child; this handles the
   case where a folder mentions nonexistent or deleted GUIDs in
   its `children`. Parents by `parentid` require the item to exist,
   but not its parent; this handles orphans that reference missing
   or non-folder parents.
3. Finally, once we've added all entries to the tree, we have a
   complete view of the structure, so we can resolve missing, multiple,
   and conflicting parents.

For cases where we know the structure is valid and in level order,
like Desktop's `Store::fetch_local_tree()`, we handle steps 1 and 2
at the same time: `builder.item(item)?.by_structure(&parent_guid)?`.

For the remote tree, we insert all items and their `parentid`s
first (`builder.item(item)?.by_parent_guid(&parent_guid)?`, where
`parent_guid` might not be in the tree), then add structure from
children later:
`builder.parent_for(&child_guid)?.by_children(&parent_guid)?`,
where `child_guid` might not be in the tree.

Closes #22."
87,https://api.github.com/repos/mozilla/dogear/pulls/23,23,Replant the tree! 🌲,"This started out as a fix for corruption corner cases, grew into
simplifying how we build the remote tree, and turned into a rewrite
(again >.>). Instead of managing two different sets of structure at
insert and merge time, we now store items and parent-child
relationships in a tree builder, then build a consistent tree that
flags divergent items.

The old tree was complicated because it had to maintain a valid
structure before and after every insert, but with references to
potentially unknown parents and children. Since we couldn't insert
an item without knowing its parent, we had to pick a canonical
structure (parents by `children`), insert children in level
order, and note divergent structure (by `parentid`) separately.

This meant Desktop's `Store::fetch_remote_tree()` had to left-join
`mirror.items` to `mirror.structure`, store the items in a
pseudo-tree, then recursively walk children to inflate the complete
tree. This was complicated enough with a valid tree, let alone
orphans and multiple parents.

With the new approach, we build the tree in three steps:

1. First, we add all items, without structure.
2. Next, we set parent-child relationships. Parents by `children`
   require the parent to exist, but not the child; this handles the
   case where a folder mentions nonexistent or deleted GUIDs in
   its `children`. Parents by `parentid` require the item to exist,
   but not its parent; this handles orphans that reference missing
   or non-folder parents.
3. Finally, once we've added all entries to the tree, we have a
   complete view of the structure, so we can resolve missing, multiple,
   and conflicting parents.

For cases where we know the structure is valid and in level order,
like Desktop's `Store::fetch_local_tree()`, we handle steps 1 and 2
at the same time: `builder.item(item)?.by_structure(&parent_guid)?`.

For the remote tree, we insert all items and their `parentid`s
first (`builder.item(item)?.by_parent_guid(&parent_guid)?`, where
`parent_guid` might not be in the tree), then add structure from
children later:
`builder.parent_for(&child_guid)?.by_children(&parent_guid)?`,
where `child_guid` might not be in the tree.

Closes #22.",linacambridge,41387967,2019-02-13T01:42:25Z,CONTRIBUTOR,True,745,677,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,8c054b670715a869d1a47da05fbfc45fa62351c6,Add cycle detection. See #22.
88,https://api.github.com/repos/mozilla/dogear/pulls/23,23,Replant the tree! 🌲,"This started out as a fix for corruption corner cases, grew into
simplifying how we build the remote tree, and turned into a rewrite
(again >.>). Instead of managing two different sets of structure at
insert and merge time, we now store items and parent-child
relationships in a tree builder, then build a consistent tree that
flags divergent items.

The old tree was complicated because it had to maintain a valid
structure before and after every insert, but with references to
potentially unknown parents and children. Since we couldn't insert
an item without knowing its parent, we had to pick a canonical
structure (parents by `children`), insert children in level
order, and note divergent structure (by `parentid`) separately.

This meant Desktop's `Store::fetch_remote_tree()` had to left-join
`mirror.items` to `mirror.structure`, store the items in a
pseudo-tree, then recursively walk children to inflate the complete
tree. This was complicated enough with a valid tree, let alone
orphans and multiple parents.

With the new approach, we build the tree in three steps:

1. First, we add all items, without structure.
2. Next, we set parent-child relationships. Parents by `children`
   require the parent to exist, but not the child; this handles the
   case where a folder mentions nonexistent or deleted GUIDs in
   its `children`. Parents by `parentid` require the item to exist,
   but not its parent; this handles orphans that reference missing
   or non-folder parents.
3. Finally, once we've added all entries to the tree, we have a
   complete view of the structure, so we can resolve missing, multiple,
   and conflicting parents.

For cases where we know the structure is valid and in level order,
like Desktop's `Store::fetch_local_tree()`, we handle steps 1 and 2
at the same time: `builder.item(item)?.by_structure(&parent_guid)?`.

For the remote tree, we insert all items and their `parentid`s
first (`builder.item(item)?.by_parent_guid(&parent_guid)?`, where
`parent_guid` might not be in the tree), then add structure from
children later:
`builder.parent_for(&child_guid)?.by_children(&parent_guid)?`,
where `child_guid` might not be in the tree.

Closes #22.",linacambridge,41387967,2019-02-13T01:42:25Z,CONTRIBUTOR,True,745,677,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,7f5f9319a158c5509c309a8a5047e979ef72c36f,Use a `SmallBitVec` in `detect_cycles`.
89,https://api.github.com/repos/mozilla/dogear/pulls/21,21,Rolling PR for Desktop integration,"It's probably easier to review this commit-by-commit. So far, all of Desktop's tests pass 🎉 , except:

- [x] `test_bookmark_corruption.js`: Will need to be updated, since Dogear handles diverging structure. Dogear will also need to ignore root deletions and moves. Might be easier to handle this as a divergence, instead of teaching the merger to protect roots.
- [x] `test_bookmark_kinds.js`: Dogear doesn't handle livemarks specially, and fails if you try to merge a livemark and a folder (#13).
- [x] Everything that checks event telemetry, since Rust doesn't pass structure counts to JS yet.",linacambridge,41387967,2019-02-01T07:02:23Z,CONTRIBUTOR,True,658,240,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,d2715ef1b6afb24567df0b273b323d13a51224a0,"Add `MergedNode::descendants()`.

This returns an iterator that yields the merged node's descendants, in
level order."
90,https://api.github.com/repos/mozilla/dogear/pulls/21,21,Rolling PR for Desktop integration,"It's probably easier to review this commit-by-commit. So far, all of Desktop's tests pass 🎉 , except:

- [x] `test_bookmark_corruption.js`: Will need to be updated, since Dogear handles diverging structure. Dogear will also need to ignore root deletions and moves. Might be easier to handle this as a divergence, instead of teaching the merger to protect roots.
- [x] `test_bookmark_kinds.js`: Dogear doesn't handle livemarks specially, and fails if you try to merge a livemark and a folder (#13).
- [x] Everything that checks event telemetry, since Rust doesn't pass structure counts to JS yet.",linacambridge,41387967,2019-02-01T07:02:23Z,CONTRIBUTOR,True,658,240,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,65b056d7d6b44d3a4d682f0d1fb60590fbd85eb0,"Add `{Local, Remote}Only` merge states; remove `LocalWithNewStructure`.

Before `Unchanged`, `Local` meant ""keep local and maybe upload"", and
`LocalWithNewStructure` meant ""keep local and always upload"". Now
that `Unchanged` exists, `Local` means ""keep local and upload"", so
`LocalWithNewStructure` is redundant.

Further, it wasn't obvious that `Local { remote_node: None }` meant
the item only exists locally, and should be uploaded unconditionally,
and `Remote { local_node: None }` meant the item only exists remotely,
and should be applied unconditionally. This commit changes `Local`
and `Remote` to mean ""exists on both sides, but prefer one"", and adds
`LocalOnly`, `RemoteOnly`, and `RemoteOnlyWithNewStructure` to mean
""exists on one side, so take unconditionally"".

To that end, this commit treats remotely changed user content roots as
`Unchanged`. As of bug 1432614, roots don't have user-editable titles,
so applying remote title changes is unnecessary. However, we also don't
mark the roots as `Local`, because that would mean we'd reupload the
root _every time_ it was changed remotely.

Finally, we want callers to easily determine whether to apply remote
changes, and upload local and new changes. This commit adds
`MergeState::{should_apply, should_upload}()` for that."
91,https://api.github.com/repos/mozilla/dogear/pulls/21,21,Rolling PR for Desktop integration,"It's probably easier to review this commit-by-commit. So far, all of Desktop's tests pass 🎉 , except:

- [x] `test_bookmark_corruption.js`: Will need to be updated, since Dogear handles diverging structure. Dogear will also need to ignore root deletions and moves. Might be easier to handle this as a divergence, instead of teaching the merger to protect roots.
- [x] `test_bookmark_kinds.js`: Dogear doesn't handle livemarks specially, and fails if you try to merge a livemark and a folder (#13).
- [x] Everything that checks event telemetry, since Rust doesn't pass structure counts to JS yet.",linacambridge,41387967,2019-02-01T07:02:23Z,CONTRIBUTOR,True,658,240,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,917fc439b8bc61ce14ce46786cedfd8d03c0dcf0,Add docs and `inline` attributes to tree methods.
92,https://api.github.com/repos/mozilla/dogear/pulls/21,21,Rolling PR for Desktop integration,"It's probably easier to review this commit-by-commit. So far, all of Desktop's tests pass 🎉 , except:

- [x] `test_bookmark_corruption.js`: Will need to be updated, since Dogear handles diverging structure. Dogear will also need to ignore root deletions and moves. Might be easier to handle this as a divergence, instead of teaching the merger to protect roots.
- [x] `test_bookmark_kinds.js`: Dogear doesn't handle livemarks specially, and fails if you try to merge a livemark and a folder (#13).
- [x] Everything that checks event telemetry, since Rust doesn't pass structure counts to JS yet.",linacambridge,41387967,2019-02-01T07:02:23Z,CONTRIBUTOR,True,658,240,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,57c9c538d3b6a6ed744852e2aaccdfabb50d3018,Add a `guid::IsValid` trait for `Guid`s and byte slices.
93,https://api.github.com/repos/mozilla/dogear/pulls/21,21,Rolling PR for Desktop integration,"It's probably easier to review this commit-by-commit. So far, all of Desktop's tests pass 🎉 , except:

- [x] `test_bookmark_corruption.js`: Will need to be updated, since Dogear handles diverging structure. Dogear will also need to ignore root deletions and moves. Might be easier to handle this as a divergence, instead of teaching the merger to protect roots.
- [x] `test_bookmark_kinds.js`: Dogear doesn't handle livemarks specially, and fails if you try to merge a livemark and a folder (#13).
- [x] Everything that checks event telemetry, since Rust doesn't pass structure counts to JS yet.",linacambridge,41387967,2019-02-01T07:02:23Z,CONTRIBUTOR,True,658,240,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,b9c8d330c79912405477238762cca211f6fc1d1d,Don't allow roots to be moved or deleted.
94,https://api.github.com/repos/mozilla/dogear/pulls/21,21,Rolling PR for Desktop integration,"It's probably easier to review this commit-by-commit. So far, all of Desktop's tests pass 🎉 , except:

- [x] `test_bookmark_corruption.js`: Will need to be updated, since Dogear handles diverging structure. Dogear will also need to ignore root deletions and moves. Might be easier to handle this as a divergence, instead of teaching the merger to protect roots.
- [x] `test_bookmark_kinds.js`: Dogear doesn't handle livemarks specially, and fails if you try to merge a livemark and a folder (#13).
- [x] Everything that checks event telemetry, since Rust doesn't pass structure counts to JS yet.",linacambridge,41387967,2019-02-01T07:02:23Z,CONTRIBUTOR,True,658,240,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,13114ea26c245f439114394d118cb9d65dbf3cbd,"Track item validity states and flag invalid items for reupload.

This ports the merger parts of
https://bugzilla.mozilla.org/show_bug.cgi?id=1515784."
95,https://api.github.com/repos/mozilla/dogear/pulls/21,21,Rolling PR for Desktop integration,"It's probably easier to review this commit-by-commit. So far, all of Desktop's tests pass 🎉 , except:

- [x] `test_bookmark_corruption.js`: Will need to be updated, since Dogear handles diverging structure. Dogear will also need to ignore root deletions and moves. Might be easier to handle this as a divergence, instead of teaching the merger to protect roots.
- [x] `test_bookmark_kinds.js`: Dogear doesn't handle livemarks specially, and fails if you try to merge a livemark and a folder (#13).
- [x] Everything that checks event telemetry, since Rust doesn't pass structure counts to JS yet.",linacambridge,41387967,2019-02-01T07:02:23Z,CONTRIBUTOR,True,658,240,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,0477bf47795ad49345e6518dfdb331634a8ed50c,Compare timestamps instead of taking the other side for diverged items.
96,https://api.github.com/repos/mozilla/dogear/pulls/21,21,Rolling PR for Desktop integration,"It's probably easier to review this commit-by-commit. So far, all of Desktop's tests pass 🎉 , except:

- [x] `test_bookmark_corruption.js`: Will need to be updated, since Dogear handles diverging structure. Dogear will also need to ignore root deletions and moves. Might be easier to handle this as a divergence, instead of teaching the merger to protect roots.
- [x] `test_bookmark_kinds.js`: Dogear doesn't handle livemarks specially, and fails if you try to merge a livemark and a folder (#13).
- [x] Everything that checks event telemetry, since Rust doesn't pass structure counts to JS yet.",linacambridge,41387967,2019-02-01T07:02:23Z,CONTRIBUTOR,True,658,240,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,d84a6bc75927410a4f10f4c43da2a439a0463a8d,Rename `guid::IsValid` to `guid::IsValidGuid`.
97,https://api.github.com/repos/mozilla/dogear/pulls/21,21,Rolling PR for Desktop integration,"It's probably easier to review this commit-by-commit. So far, all of Desktop's tests pass 🎉 , except:

- [x] `test_bookmark_corruption.js`: Will need to be updated, since Dogear handles diverging structure. Dogear will also need to ignore root deletions and moves. Might be easier to handle this as a divergence, instead of teaching the merger to protect roots.
- [x] `test_bookmark_kinds.js`: Dogear doesn't handle livemarks specially, and fails if you try to merge a livemark and a folder (#13).
- [x] Everything that checks event telemetry, since Rust doesn't pass structure counts to JS yet.",linacambridge,41387967,2019-02-01T07:02:23Z,CONTRIBUTOR,True,658,240,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,5cdef6909243f0198bc85978232e31e24d853984,Ignore `Repr` when comparing and hashing GUIDs.
98,https://api.github.com/repos/mozilla/dogear/pulls/21,21,Rolling PR for Desktop integration,"It's probably easier to review this commit-by-commit. So far, all of Desktop's tests pass 🎉 , except:

- [x] `test_bookmark_corruption.js`: Will need to be updated, since Dogear handles diverging structure. Dogear will also need to ignore root deletions and moves. Might be easier to handle this as a divergence, instead of teaching the merger to protect roots.
- [x] `test_bookmark_kinds.js`: Dogear doesn't handle livemarks specially, and fails if you try to merge a livemark and a folder (#13).
- [x] Everything that checks event telemetry, since Rust doesn't pass structure counts to JS yet.",linacambridge,41387967,2019-02-01T07:02:23Z,CONTRIBUTOR,True,658,240,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,95eebf3f447eec2086328aa33361de2487a1c90a,Collect descendants and deletions instead of returning an iterator.
99,https://api.github.com/repos/mozilla/dogear/pulls/21,21,Rolling PR for Desktop integration,"It's probably easier to review this commit-by-commit. So far, all of Desktop's tests pass 🎉 , except:

- [x] `test_bookmark_corruption.js`: Will need to be updated, since Dogear handles diverging structure. Dogear will also need to ignore root deletions and moves. Might be easier to handle this as a divergence, instead of teaching the merger to protect roots.
- [x] `test_bookmark_kinds.js`: Dogear doesn't handle livemarks specially, and fails if you try to merge a livemark and a folder (#13).
- [x] Everything that checks event telemetry, since Rust doesn't pass structure counts to JS yet.",linacambridge,41387967,2019-02-01T07:02:23Z,CONTRIBUTOR,True,658,240,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,7758dec2a0bbd1bea192083e3bdc5ef8c6f66fc3,Log merged local and remote deletions.
100,https://api.github.com/repos/mozilla/dogear/pulls/21,21,Rolling PR for Desktop integration,"It's probably easier to review this commit-by-commit. So far, all of Desktop's tests pass 🎉 , except:

- [x] `test_bookmark_corruption.js`: Will need to be updated, since Dogear handles diverging structure. Dogear will also need to ignore root deletions and moves. Might be easier to handle this as a divergence, instead of teaching the merger to protect roots.
- [x] `test_bookmark_kinds.js`: Dogear doesn't handle livemarks specially, and fails if you try to merge a livemark and a folder (#13).
- [x] Everything that checks event telemetry, since Rust doesn't pass structure counts to JS yet.",linacambridge,41387967,2019-02-01T07:02:23Z,CONTRIBUTOR,True,658,240,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,6289e75fd13a3b147ed796ca319e86a53a531d45,Treat remote livemarks and diverged queries as non-syncable.
101,https://api.github.com/repos/mozilla/dogear/pulls/20,20,Replace `log` with a simple local logger,"The `log` crate uses a global logger that can only be registered once,
at startup. Unfortunately, this won't work for Desktop, where we want
to integrate with Sync's existing logging setup. We also don't want to
impact other crates in `gkrust` that use `log`.

This commit replaces `log` with a quick-and-dirty implementation on
`Driver`, and some macros that take care of calling `format_args!()`.
We can extend these later to pass `file!()` and `line!()`, if we
want.

This commit also changes `Merger` to hold a reference to `Driver`.
On Desktop, the driver accumulates log messages on the storage
thread, and accesses them on the main thread.",linacambridge,41387967,2019-01-30T04:07:17Z,CONTRIBUTOR,True,167,113,6,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,0d9e7961ed0efd9062e4014f8e96a3655503ddb4,"Replace `log` with a simple local logger.

The `log` crate uses a global logger that can only be registered once,
at startup. Unfortunately, this won't work for Desktop, where we want
to integrate with Sync's existing logging setup. We also don't want to
impact other crates in `gkrust` that use `log`.

This commit replaces `log` with a quick-and-dirty implementation on
`Driver`, and some macros that take care of calling `format_args!()`.
We can extend these later to pass `file!()` and `line!()`, if we
want.

This commit also changes `Merger` to hold a reference to `Driver`.
On Desktop, the driver accumulates log messages on the storage
thread, and accesses them on the main thread."
102,https://api.github.com/repos/mozilla/dogear/pulls/19,19,Fix up diverging structure in bookmark trees,"In a well-formed tree:

- Each item exists in exactly one folder. Two different folder's
  `children` should never reference the same item.
- Each folder contains existing children. A folder's `children` should
  never reference tombstones, or items that don't exist in the tree at all.
- Each item has a `parentid` that agrees with its parent's `children`. In
  other words, if item B's `parentid` is A, then A's `children` should
  contain B.

Because of Reasons, things are (a lot) messier in practice.

# Structure inconsistencies

Sync stores structure in two places: a `parentid` property on each item,
which points to its parent's GUID, and a list of ordered `children` on the
item's parent. They're duplicated because, historically, Sync clients didn't
stage incoming records. Instead, they applied records one at a time,
directly to the live local tree. This meant that, if a client saw a child
before its parent, it would first use the `parentid` to decide where to keep
the child, then fix up parents and positions using the parent's `children`.

This is also why moving an item into a different folder uploads records for
the item, old folder, and new folder. The item has a new `parentid`, and the
folders have new `children`. Similarly, deleting an item uploads a tombstone
for the item, and a record for the item's old parent.

Unfortunately, bugs (bug 1258127) and missing features (bug 1253051) in
older clients sometimes caused them to upload invalid or incomplete changes.
For example, a client might have:

- Uploaded a moved child, but not its parents. This means the child now
  appears in multiple parents. In the most extreme case, an item might be
  referenced in two different sets of `children`, _and_ have a third,
  completely unrelated `parentid`.
- Deleted a child, and tracked the deletion, but didn't flag the parent for
  reupload. The parent folder now has a tombstone child.
- Tracked and uploaded items that shouldn't exist on the server at all,
  like the left pane or reading list roots (bug 1309255).
- Missed new folders created during a sync, creating holes in the tree.

Newer clients shouldn't do this, but we might still have inconsistent
records on the server that will confuse older clients. Additionally, Firefox
for iOS includes a much stricter bookmarks engine that refuses to sync if
it detects inconsistencies.

# Divergences

To work around this, our tree lets the structure _diverge_. This allows:

- Items with multiple parents.
- Items with missing `parentid`s.
- Folders with `children` whose `parentid`s don't match the folder.
- Items whose `parentid`s don't mention the item in their `children`.
- Items with `parentid`s that point to nonexistent or deleted folders.
- Folders with nonexistent `children`.
- Non-syncable items, like custom roots.
- Any combination of these.

Each item in the tree has an `EntryParentFrom` tag that indicates where
its structure comes from. Structure from `children` is validated and
resolved at `insert` time, so trying to add an item to a parent that
doesn't exist or isn't a folder returns a `MissingParent` or
`InvalidParent` error.

Structure from `parentid`, if it diverges from `children`, is resolved at
merge time, when the merger walks the complete tree. You can think of this
distinction as similar to early vs. late binding. The `parentid`, if
different from the parent's `children`, might not exist in the tree at
`insert` time, either because the parent hasn't been added yet, or because
it doesn't exist in the tree at all.

# Resolving divergences

Walking the tree, using `Tree::node_for_guid`, `Node::parent`, and
`Node::children`, resolves divergences using these rules:

1. Items that appear in multiple `children`, and items with mismatched
   `parentid`s, use the chronologically newer parent, based on the parent's
   last modified time. We always prefer structure from `children` over
   `parentid,` because `children` also gives us the item's position.
2. Items that aren't mentioned in any parent's `children`, but have a
   `parentid` that references an existing folder in the tree, are reparented
   to the end of that folder, after the folder's `children`.
3. Items that reference a nonexistent or non-folder `parentid`, or don't
   have a `parentid` at all, are reparented to the default folder, after any
   `children` and items from rule 2.
4. If the default folder isn't set, or doesn't exist, items from rule 3 are
   reparented to the root instead.

The result is a well-formed tree structure that can be merged. The merger
detects if the structure diverged, and flags affected items for reupload.

Closes #18.",linacambridge,41387967,2019-01-09T14:54:41Z,CONTRIBUTOR,True,1180,333,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,b5e38d48f1c48a902e6140141048e7425916b5cc,Add an `Item::Missing` representation for missing items.
103,https://api.github.com/repos/mozilla/dogear/pulls/19,19,Fix up diverging structure in bookmark trees,"In a well-formed tree:

- Each item exists in exactly one folder. Two different folder's
  `children` should never reference the same item.
- Each folder contains existing children. A folder's `children` should
  never reference tombstones, or items that don't exist in the tree at all.
- Each item has a `parentid` that agrees with its parent's `children`. In
  other words, if item B's `parentid` is A, then A's `children` should
  contain B.

Because of Reasons, things are (a lot) messier in practice.

# Structure inconsistencies

Sync stores structure in two places: a `parentid` property on each item,
which points to its parent's GUID, and a list of ordered `children` on the
item's parent. They're duplicated because, historically, Sync clients didn't
stage incoming records. Instead, they applied records one at a time,
directly to the live local tree. This meant that, if a client saw a child
before its parent, it would first use the `parentid` to decide where to keep
the child, then fix up parents and positions using the parent's `children`.

This is also why moving an item into a different folder uploads records for
the item, old folder, and new folder. The item has a new `parentid`, and the
folders have new `children`. Similarly, deleting an item uploads a tombstone
for the item, and a record for the item's old parent.

Unfortunately, bugs (bug 1258127) and missing features (bug 1253051) in
older clients sometimes caused them to upload invalid or incomplete changes.
For example, a client might have:

- Uploaded a moved child, but not its parents. This means the child now
  appears in multiple parents. In the most extreme case, an item might be
  referenced in two different sets of `children`, _and_ have a third,
  completely unrelated `parentid`.
- Deleted a child, and tracked the deletion, but didn't flag the parent for
  reupload. The parent folder now has a tombstone child.
- Tracked and uploaded items that shouldn't exist on the server at all,
  like the left pane or reading list roots (bug 1309255).
- Missed new folders created during a sync, creating holes in the tree.

Newer clients shouldn't do this, but we might still have inconsistent
records on the server that will confuse older clients. Additionally, Firefox
for iOS includes a much stricter bookmarks engine that refuses to sync if
it detects inconsistencies.

# Divergences

To work around this, our tree lets the structure _diverge_. This allows:

- Items with multiple parents.
- Items with missing `parentid`s.
- Folders with `children` whose `parentid`s don't match the folder.
- Items whose `parentid`s don't mention the item in their `children`.
- Items with `parentid`s that point to nonexistent or deleted folders.
- Folders with nonexistent `children`.
- Non-syncable items, like custom roots.
- Any combination of these.

Each item in the tree has an `EntryParentFrom` tag that indicates where
its structure comes from. Structure from `children` is validated and
resolved at `insert` time, so trying to add an item to a parent that
doesn't exist or isn't a folder returns a `MissingParent` or
`InvalidParent` error.

Structure from `parentid`, if it diverges from `children`, is resolved at
merge time, when the merger walks the complete tree. You can think of this
distinction as similar to early vs. late binding. The `parentid`, if
different from the parent's `children`, might not exist in the tree at
`insert` time, either because the parent hasn't been added yet, or because
it doesn't exist in the tree at all.

# Resolving divergences

Walking the tree, using `Tree::node_for_guid`, `Node::parent`, and
`Node::children`, resolves divergences using these rules:

1. Items that appear in multiple `children`, and items with mismatched
   `parentid`s, use the chronologically newer parent, based on the parent's
   last modified time. We always prefer structure from `children` over
   `parentid,` because `children` also gives us the item's position.
2. Items that aren't mentioned in any parent's `children`, but have a
   `parentid` that references an existing folder in the tree, are reparented
   to the end of that folder, after the folder's `children`.
3. Items that reference a nonexistent or non-folder `parentid`, or don't
   have a `parentid` at all, are reparented to the default folder, after any
   `children` and items from rule 2.
4. If the default folder isn't set, or doesn't exist, items from rule 3 are
   reparented to the root instead.

The result is a well-formed tree structure that can be merged. The merger
detects if the structure diverged, and flags affected items for reupload.

Closes #18.",linacambridge,41387967,2019-01-09T14:54:41Z,CONTRIBUTOR,True,1180,333,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,f84472207a7ef2cb2b49fe4d662905356ac68c63,Rewrite the tree to support diverging structure.
104,https://api.github.com/repos/mozilla/dogear/pulls/19,19,Fix up diverging structure in bookmark trees,"In a well-formed tree:

- Each item exists in exactly one folder. Two different folder's
  `children` should never reference the same item.
- Each folder contains existing children. A folder's `children` should
  never reference tombstones, or items that don't exist in the tree at all.
- Each item has a `parentid` that agrees with its parent's `children`. In
  other words, if item B's `parentid` is A, then A's `children` should
  contain B.

Because of Reasons, things are (a lot) messier in practice.

# Structure inconsistencies

Sync stores structure in two places: a `parentid` property on each item,
which points to its parent's GUID, and a list of ordered `children` on the
item's parent. They're duplicated because, historically, Sync clients didn't
stage incoming records. Instead, they applied records one at a time,
directly to the live local tree. This meant that, if a client saw a child
before its parent, it would first use the `parentid` to decide where to keep
the child, then fix up parents and positions using the parent's `children`.

This is also why moving an item into a different folder uploads records for
the item, old folder, and new folder. The item has a new `parentid`, and the
folders have new `children`. Similarly, deleting an item uploads a tombstone
for the item, and a record for the item's old parent.

Unfortunately, bugs (bug 1258127) and missing features (bug 1253051) in
older clients sometimes caused them to upload invalid or incomplete changes.
For example, a client might have:

- Uploaded a moved child, but not its parents. This means the child now
  appears in multiple parents. In the most extreme case, an item might be
  referenced in two different sets of `children`, _and_ have a third,
  completely unrelated `parentid`.
- Deleted a child, and tracked the deletion, but didn't flag the parent for
  reupload. The parent folder now has a tombstone child.
- Tracked and uploaded items that shouldn't exist on the server at all,
  like the left pane or reading list roots (bug 1309255).
- Missed new folders created during a sync, creating holes in the tree.

Newer clients shouldn't do this, but we might still have inconsistent
records on the server that will confuse older clients. Additionally, Firefox
for iOS includes a much stricter bookmarks engine that refuses to sync if
it detects inconsistencies.

# Divergences

To work around this, our tree lets the structure _diverge_. This allows:

- Items with multiple parents.
- Items with missing `parentid`s.
- Folders with `children` whose `parentid`s don't match the folder.
- Items whose `parentid`s don't mention the item in their `children`.
- Items with `parentid`s that point to nonexistent or deleted folders.
- Folders with nonexistent `children`.
- Non-syncable items, like custom roots.
- Any combination of these.

Each item in the tree has an `EntryParentFrom` tag that indicates where
its structure comes from. Structure from `children` is validated and
resolved at `insert` time, so trying to add an item to a parent that
doesn't exist or isn't a folder returns a `MissingParent` or
`InvalidParent` error.

Structure from `parentid`, if it diverges from `children`, is resolved at
merge time, when the merger walks the complete tree. You can think of this
distinction as similar to early vs. late binding. The `parentid`, if
different from the parent's `children`, might not exist in the tree at
`insert` time, either because the parent hasn't been added yet, or because
it doesn't exist in the tree at all.

# Resolving divergences

Walking the tree, using `Tree::node_for_guid`, `Node::parent`, and
`Node::children`, resolves divergences using these rules:

1. Items that appear in multiple `children`, and items with mismatched
   `parentid`s, use the chronologically newer parent, based on the parent's
   last modified time. We always prefer structure from `children` over
   `parentid,` because `children` also gives us the item's position.
2. Items that aren't mentioned in any parent's `children`, but have a
   `parentid` that references an existing folder in the tree, are reparented
   to the end of that folder, after the folder's `children`.
3. Items that reference a nonexistent or non-folder `parentid`, or don't
   have a `parentid` at all, are reparented to the default folder, after any
   `children` and items from rule 2.
4. If the default folder isn't set, or doesn't exist, items from rule 3 are
   reparented to the root instead.

The result is a well-formed tree structure that can be merged. The merger
detects if the structure diverged, and flags affected items for reupload.

Closes #18.",linacambridge,41387967,2019-01-09T14:54:41Z,CONTRIBUTOR,True,1180,333,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,eeaee8faa9af229eef599028c7e2f6dc1b8d424f,Reupload diverged nodes.
105,https://api.github.com/repos/mozilla/dogear/pulls/19,19,Fix up diverging structure in bookmark trees,"In a well-formed tree:

- Each item exists in exactly one folder. Two different folder's
  `children` should never reference the same item.
- Each folder contains existing children. A folder's `children` should
  never reference tombstones, or items that don't exist in the tree at all.
- Each item has a `parentid` that agrees with its parent's `children`. In
  other words, if item B's `parentid` is A, then A's `children` should
  contain B.

Because of Reasons, things are (a lot) messier in practice.

# Structure inconsistencies

Sync stores structure in two places: a `parentid` property on each item,
which points to its parent's GUID, and a list of ordered `children` on the
item's parent. They're duplicated because, historically, Sync clients didn't
stage incoming records. Instead, they applied records one at a time,
directly to the live local tree. This meant that, if a client saw a child
before its parent, it would first use the `parentid` to decide where to keep
the child, then fix up parents and positions using the parent's `children`.

This is also why moving an item into a different folder uploads records for
the item, old folder, and new folder. The item has a new `parentid`, and the
folders have new `children`. Similarly, deleting an item uploads a tombstone
for the item, and a record for the item's old parent.

Unfortunately, bugs (bug 1258127) and missing features (bug 1253051) in
older clients sometimes caused them to upload invalid or incomplete changes.
For example, a client might have:

- Uploaded a moved child, but not its parents. This means the child now
  appears in multiple parents. In the most extreme case, an item might be
  referenced in two different sets of `children`, _and_ have a third,
  completely unrelated `parentid`.
- Deleted a child, and tracked the deletion, but didn't flag the parent for
  reupload. The parent folder now has a tombstone child.
- Tracked and uploaded items that shouldn't exist on the server at all,
  like the left pane or reading list roots (bug 1309255).
- Missed new folders created during a sync, creating holes in the tree.

Newer clients shouldn't do this, but we might still have inconsistent
records on the server that will confuse older clients. Additionally, Firefox
for iOS includes a much stricter bookmarks engine that refuses to sync if
it detects inconsistencies.

# Divergences

To work around this, our tree lets the structure _diverge_. This allows:

- Items with multiple parents.
- Items with missing `parentid`s.
- Folders with `children` whose `parentid`s don't match the folder.
- Items whose `parentid`s don't mention the item in their `children`.
- Items with `parentid`s that point to nonexistent or deleted folders.
- Folders with nonexistent `children`.
- Non-syncable items, like custom roots.
- Any combination of these.

Each item in the tree has an `EntryParentFrom` tag that indicates where
its structure comes from. Structure from `children` is validated and
resolved at `insert` time, so trying to add an item to a parent that
doesn't exist or isn't a folder returns a `MissingParent` or
`InvalidParent` error.

Structure from `parentid`, if it diverges from `children`, is resolved at
merge time, when the merger walks the complete tree. You can think of this
distinction as similar to early vs. late binding. The `parentid`, if
different from the parent's `children`, might not exist in the tree at
`insert` time, either because the parent hasn't been added yet, or because
it doesn't exist in the tree at all.

# Resolving divergences

Walking the tree, using `Tree::node_for_guid`, `Node::parent`, and
`Node::children`, resolves divergences using these rules:

1. Items that appear in multiple `children`, and items with mismatched
   `parentid`s, use the chronologically newer parent, based on the parent's
   last modified time. We always prefer structure from `children` over
   `parentid,` because `children` also gives us the item's position.
2. Items that aren't mentioned in any parent's `children`, but have a
   `parentid` that references an existing folder in the tree, are reparented
   to the end of that folder, after the folder's `children`.
3. Items that reference a nonexistent or non-folder `parentid`, or don't
   have a `parentid` at all, are reparented to the default folder, after any
   `children` and items from rule 2.
4. If the default folder isn't set, or doesn't exist, items from rule 3 are
   reparented to the root instead.

The result is a well-formed tree structure that can be merged. The merger
detects if the structure diverged, and flags affected items for reupload.

Closes #18.",linacambridge,41387967,2019-01-09T14:54:41Z,CONTRIBUTOR,True,1180,333,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,615707fadde26fb9df84f70eb4508e3be0e6b4ff,Change invalid item GUIDs when merging.
106,https://api.github.com/repos/mozilla/dogear/pulls/19,19,Fix up diverging structure in bookmark trees,"In a well-formed tree:

- Each item exists in exactly one folder. Two different folder's
  `children` should never reference the same item.
- Each folder contains existing children. A folder's `children` should
  never reference tombstones, or items that don't exist in the tree at all.
- Each item has a `parentid` that agrees with its parent's `children`. In
  other words, if item B's `parentid` is A, then A's `children` should
  contain B.

Because of Reasons, things are (a lot) messier in practice.

# Structure inconsistencies

Sync stores structure in two places: a `parentid` property on each item,
which points to its parent's GUID, and a list of ordered `children` on the
item's parent. They're duplicated because, historically, Sync clients didn't
stage incoming records. Instead, they applied records one at a time,
directly to the live local tree. This meant that, if a client saw a child
before its parent, it would first use the `parentid` to decide where to keep
the child, then fix up parents and positions using the parent's `children`.

This is also why moving an item into a different folder uploads records for
the item, old folder, and new folder. The item has a new `parentid`, and the
folders have new `children`. Similarly, deleting an item uploads a tombstone
for the item, and a record for the item's old parent.

Unfortunately, bugs (bug 1258127) and missing features (bug 1253051) in
older clients sometimes caused them to upload invalid or incomplete changes.
For example, a client might have:

- Uploaded a moved child, but not its parents. This means the child now
  appears in multiple parents. In the most extreme case, an item might be
  referenced in two different sets of `children`, _and_ have a third,
  completely unrelated `parentid`.
- Deleted a child, and tracked the deletion, but didn't flag the parent for
  reupload. The parent folder now has a tombstone child.
- Tracked and uploaded items that shouldn't exist on the server at all,
  like the left pane or reading list roots (bug 1309255).
- Missed new folders created during a sync, creating holes in the tree.

Newer clients shouldn't do this, but we might still have inconsistent
records on the server that will confuse older clients. Additionally, Firefox
for iOS includes a much stricter bookmarks engine that refuses to sync if
it detects inconsistencies.

# Divergences

To work around this, our tree lets the structure _diverge_. This allows:

- Items with multiple parents.
- Items with missing `parentid`s.
- Folders with `children` whose `parentid`s don't match the folder.
- Items whose `parentid`s don't mention the item in their `children`.
- Items with `parentid`s that point to nonexistent or deleted folders.
- Folders with nonexistent `children`.
- Non-syncable items, like custom roots.
- Any combination of these.

Each item in the tree has an `EntryParentFrom` tag that indicates where
its structure comes from. Structure from `children` is validated and
resolved at `insert` time, so trying to add an item to a parent that
doesn't exist or isn't a folder returns a `MissingParent` or
`InvalidParent` error.

Structure from `parentid`, if it diverges from `children`, is resolved at
merge time, when the merger walks the complete tree. You can think of this
distinction as similar to early vs. late binding. The `parentid`, if
different from the parent's `children`, might not exist in the tree at
`insert` time, either because the parent hasn't been added yet, or because
it doesn't exist in the tree at all.

# Resolving divergences

Walking the tree, using `Tree::node_for_guid`, `Node::parent`, and
`Node::children`, resolves divergences using these rules:

1. Items that appear in multiple `children`, and items with mismatched
   `parentid`s, use the chronologically newer parent, based on the parent's
   last modified time. We always prefer structure from `children` over
   `parentid,` because `children` also gives us the item's position.
2. Items that aren't mentioned in any parent's `children`, but have a
   `parentid` that references an existing folder in the tree, are reparented
   to the end of that folder, after the folder's `children`.
3. Items that reference a nonexistent or non-folder `parentid`, or don't
   have a `parentid` at all, are reparented to the default folder, after any
   `children` and items from rule 2.
4. If the default folder isn't set, or doesn't exist, items from rule 3 are
   reparented to the root instead.

The result is a well-formed tree structure that can be merged. The merger
detects if the structure diverged, and flags affected items for reupload.

Closes #18.",linacambridge,41387967,2019-01-09T14:54:41Z,CONTRIBUTOR,True,1180,333,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,8225591456bf49e25531f835f864f8ec7a657441,"Don't store placeholders for missing children in entries.

Originally, I'd intended for the tree to expose diverging structure to
the merger, and for the merger to fix it. That was part of why I split
`Item` into `Existing` and `Missing` variants.

However, it turns out it's simpler to resolve divergences in the tree,
and expose a well-formed structure to the merger instead. Changing
`Item` to an enum means we now need a pattern match for _every_ item,
when all we really want is a flag on the parent that says ""this folder
has diverged because it has a missing child"".

`Entry::divergence` already flags diverging structure for multiple
parents, so let's use it to also flag parents with missing children,
instead of forcing the merger to handle invalid structure for this one
case."
107,https://api.github.com/repos/mozilla/dogear/pulls/19,19,Fix up diverging structure in bookmark trees,"In a well-formed tree:

- Each item exists in exactly one folder. Two different folder's
  `children` should never reference the same item.
- Each folder contains existing children. A folder's `children` should
  never reference tombstones, or items that don't exist in the tree at all.
- Each item has a `parentid` that agrees with its parent's `children`. In
  other words, if item B's `parentid` is A, then A's `children` should
  contain B.

Because of Reasons, things are (a lot) messier in practice.

# Structure inconsistencies

Sync stores structure in two places: a `parentid` property on each item,
which points to its parent's GUID, and a list of ordered `children` on the
item's parent. They're duplicated because, historically, Sync clients didn't
stage incoming records. Instead, they applied records one at a time,
directly to the live local tree. This meant that, if a client saw a child
before its parent, it would first use the `parentid` to decide where to keep
the child, then fix up parents and positions using the parent's `children`.

This is also why moving an item into a different folder uploads records for
the item, old folder, and new folder. The item has a new `parentid`, and the
folders have new `children`. Similarly, deleting an item uploads a tombstone
for the item, and a record for the item's old parent.

Unfortunately, bugs (bug 1258127) and missing features (bug 1253051) in
older clients sometimes caused them to upload invalid or incomplete changes.
For example, a client might have:

- Uploaded a moved child, but not its parents. This means the child now
  appears in multiple parents. In the most extreme case, an item might be
  referenced in two different sets of `children`, _and_ have a third,
  completely unrelated `parentid`.
- Deleted a child, and tracked the deletion, but didn't flag the parent for
  reupload. The parent folder now has a tombstone child.
- Tracked and uploaded items that shouldn't exist on the server at all,
  like the left pane or reading list roots (bug 1309255).
- Missed new folders created during a sync, creating holes in the tree.

Newer clients shouldn't do this, but we might still have inconsistent
records on the server that will confuse older clients. Additionally, Firefox
for iOS includes a much stricter bookmarks engine that refuses to sync if
it detects inconsistencies.

# Divergences

To work around this, our tree lets the structure _diverge_. This allows:

- Items with multiple parents.
- Items with missing `parentid`s.
- Folders with `children` whose `parentid`s don't match the folder.
- Items whose `parentid`s don't mention the item in their `children`.
- Items with `parentid`s that point to nonexistent or deleted folders.
- Folders with nonexistent `children`.
- Non-syncable items, like custom roots.
- Any combination of these.

Each item in the tree has an `EntryParentFrom` tag that indicates where
its structure comes from. Structure from `children` is validated and
resolved at `insert` time, so trying to add an item to a parent that
doesn't exist or isn't a folder returns a `MissingParent` or
`InvalidParent` error.

Structure from `parentid`, if it diverges from `children`, is resolved at
merge time, when the merger walks the complete tree. You can think of this
distinction as similar to early vs. late binding. The `parentid`, if
different from the parent's `children`, might not exist in the tree at
`insert` time, either because the parent hasn't been added yet, or because
it doesn't exist in the tree at all.

# Resolving divergences

Walking the tree, using `Tree::node_for_guid`, `Node::parent`, and
`Node::children`, resolves divergences using these rules:

1. Items that appear in multiple `children`, and items with mismatched
   `parentid`s, use the chronologically newer parent, based on the parent's
   last modified time. We always prefer structure from `children` over
   `parentid,` because `children` also gives us the item's position.
2. Items that aren't mentioned in any parent's `children`, but have a
   `parentid` that references an existing folder in the tree, are reparented
   to the end of that folder, after the folder's `children`.
3. Items that reference a nonexistent or non-folder `parentid`, or don't
   have a `parentid` at all, are reparented to the default folder, after any
   `children` and items from rule 2.
4. If the default folder isn't set, or doesn't exist, items from rule 3 are
   reparented to the root instead.

The result is a well-formed tree structure that can be merged. The merger
detects if the structure diverged, and flags affected items for reupload.

Closes #18.",linacambridge,41387967,2019-01-09T14:54:41Z,CONTRIBUTOR,True,1180,333,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,ea1a02240075f258df9b3a6c751a8dcab9fdc3fc,"Refactor and refine the new tree.

* Add missing doc comments.
* Rename reparenting methods for clarity.
* Move `Tree::{children, parent}_for_entry` to
  `Node::{children, parent}`.
* Remove optional return value from `Node::level`.
* Add `Node::is_{root, default_parent_for_orphans}`.
* Iterate over `Tree::entries` instead of
  `Tree::entry_index_by_guid`. The two should point to the same
  entries, but `entries` is more direct.
* Don't mark trees with orphans as equal."
108,https://api.github.com/repos/mozilla/dogear/pulls/19,19,Fix up diverging structure in bookmark trees,"In a well-formed tree:

- Each item exists in exactly one folder. Two different folder's
  `children` should never reference the same item.
- Each folder contains existing children. A folder's `children` should
  never reference tombstones, or items that don't exist in the tree at all.
- Each item has a `parentid` that agrees with its parent's `children`. In
  other words, if item B's `parentid` is A, then A's `children` should
  contain B.

Because of Reasons, things are (a lot) messier in practice.

# Structure inconsistencies

Sync stores structure in two places: a `parentid` property on each item,
which points to its parent's GUID, and a list of ordered `children` on the
item's parent. They're duplicated because, historically, Sync clients didn't
stage incoming records. Instead, they applied records one at a time,
directly to the live local tree. This meant that, if a client saw a child
before its parent, it would first use the `parentid` to decide where to keep
the child, then fix up parents and positions using the parent's `children`.

This is also why moving an item into a different folder uploads records for
the item, old folder, and new folder. The item has a new `parentid`, and the
folders have new `children`. Similarly, deleting an item uploads a tombstone
for the item, and a record for the item's old parent.

Unfortunately, bugs (bug 1258127) and missing features (bug 1253051) in
older clients sometimes caused them to upload invalid or incomplete changes.
For example, a client might have:

- Uploaded a moved child, but not its parents. This means the child now
  appears in multiple parents. In the most extreme case, an item might be
  referenced in two different sets of `children`, _and_ have a third,
  completely unrelated `parentid`.
- Deleted a child, and tracked the deletion, but didn't flag the parent for
  reupload. The parent folder now has a tombstone child.
- Tracked and uploaded items that shouldn't exist on the server at all,
  like the left pane or reading list roots (bug 1309255).
- Missed new folders created during a sync, creating holes in the tree.

Newer clients shouldn't do this, but we might still have inconsistent
records on the server that will confuse older clients. Additionally, Firefox
for iOS includes a much stricter bookmarks engine that refuses to sync if
it detects inconsistencies.

# Divergences

To work around this, our tree lets the structure _diverge_. This allows:

- Items with multiple parents.
- Items with missing `parentid`s.
- Folders with `children` whose `parentid`s don't match the folder.
- Items whose `parentid`s don't mention the item in their `children`.
- Items with `parentid`s that point to nonexistent or deleted folders.
- Folders with nonexistent `children`.
- Non-syncable items, like custom roots.
- Any combination of these.

Each item in the tree has an `EntryParentFrom` tag that indicates where
its structure comes from. Structure from `children` is validated and
resolved at `insert` time, so trying to add an item to a parent that
doesn't exist or isn't a folder returns a `MissingParent` or
`InvalidParent` error.

Structure from `parentid`, if it diverges from `children`, is resolved at
merge time, when the merger walks the complete tree. You can think of this
distinction as similar to early vs. late binding. The `parentid`, if
different from the parent's `children`, might not exist in the tree at
`insert` time, either because the parent hasn't been added yet, or because
it doesn't exist in the tree at all.

# Resolving divergences

Walking the tree, using `Tree::node_for_guid`, `Node::parent`, and
`Node::children`, resolves divergences using these rules:

1. Items that appear in multiple `children`, and items with mismatched
   `parentid`s, use the chronologically newer parent, based on the parent's
   last modified time. We always prefer structure from `children` over
   `parentid,` because `children` also gives us the item's position.
2. Items that aren't mentioned in any parent's `children`, but have a
   `parentid` that references an existing folder in the tree, are reparented
   to the end of that folder, after the folder's `children`.
3. Items that reference a nonexistent or non-folder `parentid`, or don't
   have a `parentid` at all, are reparented to the default folder, after any
   `children` and items from rule 2.
4. If the default folder isn't set, or doesn't exist, items from rule 3 are
   reparented to the root instead.

The result is a well-formed tree structure that can be merged. The merger
detects if the structure diverged, and flags affected items for reupload.

Closes #18.",linacambridge,41387967,2019-01-09T14:54:41Z,CONTRIBUTOR,True,1180,333,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,ed65291b8ee225a96664d8ed8259795fd2785fef,"Implement a simpler, recursive `PartialEq` for trees and nodes."
109,https://api.github.com/repos/mozilla/dogear/pulls/19,19,Fix up diverging structure in bookmark trees,"In a well-formed tree:

- Each item exists in exactly one folder. Two different folder's
  `children` should never reference the same item.
- Each folder contains existing children. A folder's `children` should
  never reference tombstones, or items that don't exist in the tree at all.
- Each item has a `parentid` that agrees with its parent's `children`. In
  other words, if item B's `parentid` is A, then A's `children` should
  contain B.

Because of Reasons, things are (a lot) messier in practice.

# Structure inconsistencies

Sync stores structure in two places: a `parentid` property on each item,
which points to its parent's GUID, and a list of ordered `children` on the
item's parent. They're duplicated because, historically, Sync clients didn't
stage incoming records. Instead, they applied records one at a time,
directly to the live local tree. This meant that, if a client saw a child
before its parent, it would first use the `parentid` to decide where to keep
the child, then fix up parents and positions using the parent's `children`.

This is also why moving an item into a different folder uploads records for
the item, old folder, and new folder. The item has a new `parentid`, and the
folders have new `children`. Similarly, deleting an item uploads a tombstone
for the item, and a record for the item's old parent.

Unfortunately, bugs (bug 1258127) and missing features (bug 1253051) in
older clients sometimes caused them to upload invalid or incomplete changes.
For example, a client might have:

- Uploaded a moved child, but not its parents. This means the child now
  appears in multiple parents. In the most extreme case, an item might be
  referenced in two different sets of `children`, _and_ have a third,
  completely unrelated `parentid`.
- Deleted a child, and tracked the deletion, but didn't flag the parent for
  reupload. The parent folder now has a tombstone child.
- Tracked and uploaded items that shouldn't exist on the server at all,
  like the left pane or reading list roots (bug 1309255).
- Missed new folders created during a sync, creating holes in the tree.

Newer clients shouldn't do this, but we might still have inconsistent
records on the server that will confuse older clients. Additionally, Firefox
for iOS includes a much stricter bookmarks engine that refuses to sync if
it detects inconsistencies.

# Divergences

To work around this, our tree lets the structure _diverge_. This allows:

- Items with multiple parents.
- Items with missing `parentid`s.
- Folders with `children` whose `parentid`s don't match the folder.
- Items whose `parentid`s don't mention the item in their `children`.
- Items with `parentid`s that point to nonexistent or deleted folders.
- Folders with nonexistent `children`.
- Non-syncable items, like custom roots.
- Any combination of these.

Each item in the tree has an `EntryParentFrom` tag that indicates where
its structure comes from. Structure from `children` is validated and
resolved at `insert` time, so trying to add an item to a parent that
doesn't exist or isn't a folder returns a `MissingParent` or
`InvalidParent` error.

Structure from `parentid`, if it diverges from `children`, is resolved at
merge time, when the merger walks the complete tree. You can think of this
distinction as similar to early vs. late binding. The `parentid`, if
different from the parent's `children`, might not exist in the tree at
`insert` time, either because the parent hasn't been added yet, or because
it doesn't exist in the tree at all.

# Resolving divergences

Walking the tree, using `Tree::node_for_guid`, `Node::parent`, and
`Node::children`, resolves divergences using these rules:

1. Items that appear in multiple `children`, and items with mismatched
   `parentid`s, use the chronologically newer parent, based on the parent's
   last modified time. We always prefer structure from `children` over
   `parentid,` because `children` also gives us the item's position.
2. Items that aren't mentioned in any parent's `children`, but have a
   `parentid` that references an existing folder in the tree, are reparented
   to the end of that folder, after the folder's `children`.
3. Items that reference a nonexistent or non-folder `parentid`, or don't
   have a `parentid` at all, are reparented to the default folder, after any
   `children` and items from rule 2.
4. If the default folder isn't set, or doesn't exist, items from rule 3 are
   reparented to the root instead.

The result is a well-formed tree structure that can be merged. The merger
detects if the structure diverged, and flags affected items for reupload.

Closes #18.",linacambridge,41387967,2019-01-09T14:54:41Z,CONTRIBUTOR,True,1180,333,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,d23fd74d910a98e230b196acd28fd584af25a4bf,"Remove `Item::Missing`.

This reverts commit b5e38d48f1c48a902e6140141048e7425916b5cc."
110,https://api.github.com/repos/mozilla/dogear/pulls/19,19,Fix up diverging structure in bookmark trees,"In a well-formed tree:

- Each item exists in exactly one folder. Two different folder's
  `children` should never reference the same item.
- Each folder contains existing children. A folder's `children` should
  never reference tombstones, or items that don't exist in the tree at all.
- Each item has a `parentid` that agrees with its parent's `children`. In
  other words, if item B's `parentid` is A, then A's `children` should
  contain B.

Because of Reasons, things are (a lot) messier in practice.

# Structure inconsistencies

Sync stores structure in two places: a `parentid` property on each item,
which points to its parent's GUID, and a list of ordered `children` on the
item's parent. They're duplicated because, historically, Sync clients didn't
stage incoming records. Instead, they applied records one at a time,
directly to the live local tree. This meant that, if a client saw a child
before its parent, it would first use the `parentid` to decide where to keep
the child, then fix up parents and positions using the parent's `children`.

This is also why moving an item into a different folder uploads records for
the item, old folder, and new folder. The item has a new `parentid`, and the
folders have new `children`. Similarly, deleting an item uploads a tombstone
for the item, and a record for the item's old parent.

Unfortunately, bugs (bug 1258127) and missing features (bug 1253051) in
older clients sometimes caused them to upload invalid or incomplete changes.
For example, a client might have:

- Uploaded a moved child, but not its parents. This means the child now
  appears in multiple parents. In the most extreme case, an item might be
  referenced in two different sets of `children`, _and_ have a third,
  completely unrelated `parentid`.
- Deleted a child, and tracked the deletion, but didn't flag the parent for
  reupload. The parent folder now has a tombstone child.
- Tracked and uploaded items that shouldn't exist on the server at all,
  like the left pane or reading list roots (bug 1309255).
- Missed new folders created during a sync, creating holes in the tree.

Newer clients shouldn't do this, but we might still have inconsistent
records on the server that will confuse older clients. Additionally, Firefox
for iOS includes a much stricter bookmarks engine that refuses to sync if
it detects inconsistencies.

# Divergences

To work around this, our tree lets the structure _diverge_. This allows:

- Items with multiple parents.
- Items with missing `parentid`s.
- Folders with `children` whose `parentid`s don't match the folder.
- Items whose `parentid`s don't mention the item in their `children`.
- Items with `parentid`s that point to nonexistent or deleted folders.
- Folders with nonexistent `children`.
- Non-syncable items, like custom roots.
- Any combination of these.

Each item in the tree has an `EntryParentFrom` tag that indicates where
its structure comes from. Structure from `children` is validated and
resolved at `insert` time, so trying to add an item to a parent that
doesn't exist or isn't a folder returns a `MissingParent` or
`InvalidParent` error.

Structure from `parentid`, if it diverges from `children`, is resolved at
merge time, when the merger walks the complete tree. You can think of this
distinction as similar to early vs. late binding. The `parentid`, if
different from the parent's `children`, might not exist in the tree at
`insert` time, either because the parent hasn't been added yet, or because
it doesn't exist in the tree at all.

# Resolving divergences

Walking the tree, using `Tree::node_for_guid`, `Node::parent`, and
`Node::children`, resolves divergences using these rules:

1. Items that appear in multiple `children`, and items with mismatched
   `parentid`s, use the chronologically newer parent, based on the parent's
   last modified time. We always prefer structure from `children` over
   `parentid,` because `children` also gives us the item's position.
2. Items that aren't mentioned in any parent's `children`, but have a
   `parentid` that references an existing folder in the tree, are reparented
   to the end of that folder, after the folder's `children`.
3. Items that reference a nonexistent or non-folder `parentid`, or don't
   have a `parentid` at all, are reparented to the default folder, after any
   `children` and items from rule 2.
4. If the default folder isn't set, or doesn't exist, items from rule 3 are
   reparented to the root instead.

The result is a well-formed tree structure that can be merged. The merger
detects if the structure diverged, and flags affected items for reupload.

Closes #18.",linacambridge,41387967,2019-01-09T14:54:41Z,CONTRIBUTOR,True,1180,333,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,67b6cb7ae903866567df793c924a03a0b27fd36c,Remove unused deps.
111,https://api.github.com/repos/mozilla/dogear/pulls/19,19,Fix up diverging structure in bookmark trees,"In a well-formed tree:

- Each item exists in exactly one folder. Two different folder's
  `children` should never reference the same item.
- Each folder contains existing children. A folder's `children` should
  never reference tombstones, or items that don't exist in the tree at all.
- Each item has a `parentid` that agrees with its parent's `children`. In
  other words, if item B's `parentid` is A, then A's `children` should
  contain B.

Because of Reasons, things are (a lot) messier in practice.

# Structure inconsistencies

Sync stores structure in two places: a `parentid` property on each item,
which points to its parent's GUID, and a list of ordered `children` on the
item's parent. They're duplicated because, historically, Sync clients didn't
stage incoming records. Instead, they applied records one at a time,
directly to the live local tree. This meant that, if a client saw a child
before its parent, it would first use the `parentid` to decide where to keep
the child, then fix up parents and positions using the parent's `children`.

This is also why moving an item into a different folder uploads records for
the item, old folder, and new folder. The item has a new `parentid`, and the
folders have new `children`. Similarly, deleting an item uploads a tombstone
for the item, and a record for the item's old parent.

Unfortunately, bugs (bug 1258127) and missing features (bug 1253051) in
older clients sometimes caused them to upload invalid or incomplete changes.
For example, a client might have:

- Uploaded a moved child, but not its parents. This means the child now
  appears in multiple parents. In the most extreme case, an item might be
  referenced in two different sets of `children`, _and_ have a third,
  completely unrelated `parentid`.
- Deleted a child, and tracked the deletion, but didn't flag the parent for
  reupload. The parent folder now has a tombstone child.
- Tracked and uploaded items that shouldn't exist on the server at all,
  like the left pane or reading list roots (bug 1309255).
- Missed new folders created during a sync, creating holes in the tree.

Newer clients shouldn't do this, but we might still have inconsistent
records on the server that will confuse older clients. Additionally, Firefox
for iOS includes a much stricter bookmarks engine that refuses to sync if
it detects inconsistencies.

# Divergences

To work around this, our tree lets the structure _diverge_. This allows:

- Items with multiple parents.
- Items with missing `parentid`s.
- Folders with `children` whose `parentid`s don't match the folder.
- Items whose `parentid`s don't mention the item in their `children`.
- Items with `parentid`s that point to nonexistent or deleted folders.
- Folders with nonexistent `children`.
- Non-syncable items, like custom roots.
- Any combination of these.

Each item in the tree has an `EntryParentFrom` tag that indicates where
its structure comes from. Structure from `children` is validated and
resolved at `insert` time, so trying to add an item to a parent that
doesn't exist or isn't a folder returns a `MissingParent` or
`InvalidParent` error.

Structure from `parentid`, if it diverges from `children`, is resolved at
merge time, when the merger walks the complete tree. You can think of this
distinction as similar to early vs. late binding. The `parentid`, if
different from the parent's `children`, might not exist in the tree at
`insert` time, either because the parent hasn't been added yet, or because
it doesn't exist in the tree at all.

# Resolving divergences

Walking the tree, using `Tree::node_for_guid`, `Node::parent`, and
`Node::children`, resolves divergences using these rules:

1. Items that appear in multiple `children`, and items with mismatched
   `parentid`s, use the chronologically newer parent, based on the parent's
   last modified time. We always prefer structure from `children` over
   `parentid,` because `children` also gives us the item's position.
2. Items that aren't mentioned in any parent's `children`, but have a
   `parentid` that references an existing folder in the tree, are reparented
   to the end of that folder, after the folder's `children`.
3. Items that reference a nonexistent or non-folder `parentid`, or don't
   have a `parentid` at all, are reparented to the default folder, after any
   `children` and items from rule 2.
4. If the default folder isn't set, or doesn't exist, items from rule 3 are
   reparented to the root instead.

The result is a well-formed tree structure that can be merged. The merger
detects if the structure diverged, and flags affected items for reupload.

Closes #18.",linacambridge,41387967,2019-01-09T14:54:41Z,CONTRIBUTOR,True,1180,333,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,a1ba30b1ef49a5f8816251174feb4469131fecfe,"Reviews from @thomcc and @mhammond.

* Clarify why `merge::Driver` exists.
* Make `Merger` generic over `Driver`, instead of using a trait object.
* Use `clone` instead of `to_owned`.
* Replace `Entry#is` with `std::ptr::eq`.
* Add `MergedNode::remote_guid_changed`."
112,https://api.github.com/repos/mozilla/dogear/pulls/19,19,Fix up diverging structure in bookmark trees,"In a well-formed tree:

- Each item exists in exactly one folder. Two different folder's
  `children` should never reference the same item.
- Each folder contains existing children. A folder's `children` should
  never reference tombstones, or items that don't exist in the tree at all.
- Each item has a `parentid` that agrees with its parent's `children`. In
  other words, if item B's `parentid` is A, then A's `children` should
  contain B.

Because of Reasons, things are (a lot) messier in practice.

# Structure inconsistencies

Sync stores structure in two places: a `parentid` property on each item,
which points to its parent's GUID, and a list of ordered `children` on the
item's parent. They're duplicated because, historically, Sync clients didn't
stage incoming records. Instead, they applied records one at a time,
directly to the live local tree. This meant that, if a client saw a child
before its parent, it would first use the `parentid` to decide where to keep
the child, then fix up parents and positions using the parent's `children`.

This is also why moving an item into a different folder uploads records for
the item, old folder, and new folder. The item has a new `parentid`, and the
folders have new `children`. Similarly, deleting an item uploads a tombstone
for the item, and a record for the item's old parent.

Unfortunately, bugs (bug 1258127) and missing features (bug 1253051) in
older clients sometimes caused them to upload invalid or incomplete changes.
For example, a client might have:

- Uploaded a moved child, but not its parents. This means the child now
  appears in multiple parents. In the most extreme case, an item might be
  referenced in two different sets of `children`, _and_ have a third,
  completely unrelated `parentid`.
- Deleted a child, and tracked the deletion, but didn't flag the parent for
  reupload. The parent folder now has a tombstone child.
- Tracked and uploaded items that shouldn't exist on the server at all,
  like the left pane or reading list roots (bug 1309255).
- Missed new folders created during a sync, creating holes in the tree.

Newer clients shouldn't do this, but we might still have inconsistent
records on the server that will confuse older clients. Additionally, Firefox
for iOS includes a much stricter bookmarks engine that refuses to sync if
it detects inconsistencies.

# Divergences

To work around this, our tree lets the structure _diverge_. This allows:

- Items with multiple parents.
- Items with missing `parentid`s.
- Folders with `children` whose `parentid`s don't match the folder.
- Items whose `parentid`s don't mention the item in their `children`.
- Items with `parentid`s that point to nonexistent or deleted folders.
- Folders with nonexistent `children`.
- Non-syncable items, like custom roots.
- Any combination of these.

Each item in the tree has an `EntryParentFrom` tag that indicates where
its structure comes from. Structure from `children` is validated and
resolved at `insert` time, so trying to add an item to a parent that
doesn't exist or isn't a folder returns a `MissingParent` or
`InvalidParent` error.

Structure from `parentid`, if it diverges from `children`, is resolved at
merge time, when the merger walks the complete tree. You can think of this
distinction as similar to early vs. late binding. The `parentid`, if
different from the parent's `children`, might not exist in the tree at
`insert` time, either because the parent hasn't been added yet, or because
it doesn't exist in the tree at all.

# Resolving divergences

Walking the tree, using `Tree::node_for_guid`, `Node::parent`, and
`Node::children`, resolves divergences using these rules:

1. Items that appear in multiple `children`, and items with mismatched
   `parentid`s, use the chronologically newer parent, based on the parent's
   last modified time. We always prefer structure from `children` over
   `parentid,` because `children` also gives us the item's position.
2. Items that aren't mentioned in any parent's `children`, but have a
   `parentid` that references an existing folder in the tree, are reparented
   to the end of that folder, after the folder's `children`.
3. Items that reference a nonexistent or non-folder `parentid`, or don't
   have a `parentid` at all, are reparented to the default folder, after any
   `children` and items from rule 2.
4. If the default folder isn't set, or doesn't exist, items from rule 3 are
   reparented to the root instead.

The result is a well-formed tree structure that can be merged. The merger
detects if the structure diverged, and flags affected items for reupload.

Closes #18.",linacambridge,41387967,2019-01-09T14:54:41Z,CONTRIBUTOR,True,1180,333,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,b182366b4b1757868fd3a16cd5899df978d3ab83,"Don't store divergence on tree nodes.

In most cases, `node.2 == node.entry().divergence`, except for
orphans, default orphans, and diverging `parentid`s. This is a
surprising inconsistency that means `node_for_guid` and
`children` need to do more work to figure out if the node has
actually diverged.

This commit:

* Changes the tree to flag divergent `parentid`s at `insert` time.
* Cleans up `Tree::structure_for_insert`, to clarify what happens when
  a `parentid` is or isn't provided.
* Moves the logic for checking default folder divergences into
  `Node::diverged`.
* Replaces `EntryParents::{indices, guids}` with `EntryParents::iter()`,
  which doesn't allocate (thanks, @thomcc!)."
113,https://api.github.com/repos/mozilla/dogear/pulls/19,19,Fix up diverging structure in bookmark trees,"In a well-formed tree:

- Each item exists in exactly one folder. Two different folder's
  `children` should never reference the same item.
- Each folder contains existing children. A folder's `children` should
  never reference tombstones, or items that don't exist in the tree at all.
- Each item has a `parentid` that agrees with its parent's `children`. In
  other words, if item B's `parentid` is A, then A's `children` should
  contain B.

Because of Reasons, things are (a lot) messier in practice.

# Structure inconsistencies

Sync stores structure in two places: a `parentid` property on each item,
which points to its parent's GUID, and a list of ordered `children` on the
item's parent. They're duplicated because, historically, Sync clients didn't
stage incoming records. Instead, they applied records one at a time,
directly to the live local tree. This meant that, if a client saw a child
before its parent, it would first use the `parentid` to decide where to keep
the child, then fix up parents and positions using the parent's `children`.

This is also why moving an item into a different folder uploads records for
the item, old folder, and new folder. The item has a new `parentid`, and the
folders have new `children`. Similarly, deleting an item uploads a tombstone
for the item, and a record for the item's old parent.

Unfortunately, bugs (bug 1258127) and missing features (bug 1253051) in
older clients sometimes caused them to upload invalid or incomplete changes.
For example, a client might have:

- Uploaded a moved child, but not its parents. This means the child now
  appears in multiple parents. In the most extreme case, an item might be
  referenced in two different sets of `children`, _and_ have a third,
  completely unrelated `parentid`.
- Deleted a child, and tracked the deletion, but didn't flag the parent for
  reupload. The parent folder now has a tombstone child.
- Tracked and uploaded items that shouldn't exist on the server at all,
  like the left pane or reading list roots (bug 1309255).
- Missed new folders created during a sync, creating holes in the tree.

Newer clients shouldn't do this, but we might still have inconsistent
records on the server that will confuse older clients. Additionally, Firefox
for iOS includes a much stricter bookmarks engine that refuses to sync if
it detects inconsistencies.

# Divergences

To work around this, our tree lets the structure _diverge_. This allows:

- Items with multiple parents.
- Items with missing `parentid`s.
- Folders with `children` whose `parentid`s don't match the folder.
- Items whose `parentid`s don't mention the item in their `children`.
- Items with `parentid`s that point to nonexistent or deleted folders.
- Folders with nonexistent `children`.
- Non-syncable items, like custom roots.
- Any combination of these.

Each item in the tree has an `EntryParentFrom` tag that indicates where
its structure comes from. Structure from `children` is validated and
resolved at `insert` time, so trying to add an item to a parent that
doesn't exist or isn't a folder returns a `MissingParent` or
`InvalidParent` error.

Structure from `parentid`, if it diverges from `children`, is resolved at
merge time, when the merger walks the complete tree. You can think of this
distinction as similar to early vs. late binding. The `parentid`, if
different from the parent's `children`, might not exist in the tree at
`insert` time, either because the parent hasn't been added yet, or because
it doesn't exist in the tree at all.

# Resolving divergences

Walking the tree, using `Tree::node_for_guid`, `Node::parent`, and
`Node::children`, resolves divergences using these rules:

1. Items that appear in multiple `children`, and items with mismatched
   `parentid`s, use the chronologically newer parent, based on the parent's
   last modified time. We always prefer structure from `children` over
   `parentid,` because `children` also gives us the item's position.
2. Items that aren't mentioned in any parent's `children`, but have a
   `parentid` that references an existing folder in the tree, are reparented
   to the end of that folder, after the folder's `children`.
3. Items that reference a nonexistent or non-folder `parentid`, or don't
   have a `parentid` at all, are reparented to the default folder, after any
   `children` and items from rule 2.
4. If the default folder isn't set, or doesn't exist, items from rule 3 are
   reparented to the root instead.

The result is a well-formed tree structure that can be merged. The merger
detects if the structure diverged, and flags affected items for reupload.

Closes #18.",linacambridge,41387967,2019-01-09T14:54:41Z,CONTRIBUTOR,True,1180,333,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,25b31efdf93c834166ab6fd115e23d2ecc318674,"@pjenvey's review.

* Clean up optionals with `.map_or(...)` and `.filter(...).map(...)`.
* Explain why we use `ptr::eq` to compare entries."
114,https://api.github.com/repos/mozilla/dogear/pulls/19,19,Fix up diverging structure in bookmark trees,"In a well-formed tree:

- Each item exists in exactly one folder. Two different folder's
  `children` should never reference the same item.
- Each folder contains existing children. A folder's `children` should
  never reference tombstones, or items that don't exist in the tree at all.
- Each item has a `parentid` that agrees with its parent's `children`. In
  other words, if item B's `parentid` is A, then A's `children` should
  contain B.

Because of Reasons, things are (a lot) messier in practice.

# Structure inconsistencies

Sync stores structure in two places: a `parentid` property on each item,
which points to its parent's GUID, and a list of ordered `children` on the
item's parent. They're duplicated because, historically, Sync clients didn't
stage incoming records. Instead, they applied records one at a time,
directly to the live local tree. This meant that, if a client saw a child
before its parent, it would first use the `parentid` to decide where to keep
the child, then fix up parents and positions using the parent's `children`.

This is also why moving an item into a different folder uploads records for
the item, old folder, and new folder. The item has a new `parentid`, and the
folders have new `children`. Similarly, deleting an item uploads a tombstone
for the item, and a record for the item's old parent.

Unfortunately, bugs (bug 1258127) and missing features (bug 1253051) in
older clients sometimes caused them to upload invalid or incomplete changes.
For example, a client might have:

- Uploaded a moved child, but not its parents. This means the child now
  appears in multiple parents. In the most extreme case, an item might be
  referenced in two different sets of `children`, _and_ have a third,
  completely unrelated `parentid`.
- Deleted a child, and tracked the deletion, but didn't flag the parent for
  reupload. The parent folder now has a tombstone child.
- Tracked and uploaded items that shouldn't exist on the server at all,
  like the left pane or reading list roots (bug 1309255).
- Missed new folders created during a sync, creating holes in the tree.

Newer clients shouldn't do this, but we might still have inconsistent
records on the server that will confuse older clients. Additionally, Firefox
for iOS includes a much stricter bookmarks engine that refuses to sync if
it detects inconsistencies.

# Divergences

To work around this, our tree lets the structure _diverge_. This allows:

- Items with multiple parents.
- Items with missing `parentid`s.
- Folders with `children` whose `parentid`s don't match the folder.
- Items whose `parentid`s don't mention the item in their `children`.
- Items with `parentid`s that point to nonexistent or deleted folders.
- Folders with nonexistent `children`.
- Non-syncable items, like custom roots.
- Any combination of these.

Each item in the tree has an `EntryParentFrom` tag that indicates where
its structure comes from. Structure from `children` is validated and
resolved at `insert` time, so trying to add an item to a parent that
doesn't exist or isn't a folder returns a `MissingParent` or
`InvalidParent` error.

Structure from `parentid`, if it diverges from `children`, is resolved at
merge time, when the merger walks the complete tree. You can think of this
distinction as similar to early vs. late binding. The `parentid`, if
different from the parent's `children`, might not exist in the tree at
`insert` time, either because the parent hasn't been added yet, or because
it doesn't exist in the tree at all.

# Resolving divergences

Walking the tree, using `Tree::node_for_guid`, `Node::parent`, and
`Node::children`, resolves divergences using these rules:

1. Items that appear in multiple `children`, and items with mismatched
   `parentid`s, use the chronologically newer parent, based on the parent's
   last modified time. We always prefer structure from `children` over
   `parentid,` because `children` also gives us the item's position.
2. Items that aren't mentioned in any parent's `children`, but have a
   `parentid` that references an existing folder in the tree, are reparented
   to the end of that folder, after the folder's `children`.
3. Items that reference a nonexistent or non-folder `parentid`, or don't
   have a `parentid` at all, are reparented to the default folder, after any
   `children` and items from rule 2.
4. If the default folder isn't set, or doesn't exist, items from rule 3 are
   reparented to the root instead.

The result is a well-formed tree structure that can be merged. The merger
detects if the structure diverged, and flags affected items for reupload.

Closes #18.",linacambridge,41387967,2019-01-09T14:54:41Z,CONTRIBUTOR,True,1180,333,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,3842b40510fe30b1e2cc1cccf9d98d19da4b8441,"Naming is the hardest problem in computer science.

* Shorten import paths.
* Rename `Child::Existing` to `Child::Exists`.
* Rename `Divergence::Ok` to `Divergence::Consistent`, since `Ok`
  might be confused with `Result`."
115,https://api.github.com/repos/mozilla/dogear/pulls/19,19,Fix up diverging structure in bookmark trees,"In a well-formed tree:

- Each item exists in exactly one folder. Two different folder's
  `children` should never reference the same item.
- Each folder contains existing children. A folder's `children` should
  never reference tombstones, or items that don't exist in the tree at all.
- Each item has a `parentid` that agrees with its parent's `children`. In
  other words, if item B's `parentid` is A, then A's `children` should
  contain B.

Because of Reasons, things are (a lot) messier in practice.

# Structure inconsistencies

Sync stores structure in two places: a `parentid` property on each item,
which points to its parent's GUID, and a list of ordered `children` on the
item's parent. They're duplicated because, historically, Sync clients didn't
stage incoming records. Instead, they applied records one at a time,
directly to the live local tree. This meant that, if a client saw a child
before its parent, it would first use the `parentid` to decide where to keep
the child, then fix up parents and positions using the parent's `children`.

This is also why moving an item into a different folder uploads records for
the item, old folder, and new folder. The item has a new `parentid`, and the
folders have new `children`. Similarly, deleting an item uploads a tombstone
for the item, and a record for the item's old parent.

Unfortunately, bugs (bug 1258127) and missing features (bug 1253051) in
older clients sometimes caused them to upload invalid or incomplete changes.
For example, a client might have:

- Uploaded a moved child, but not its parents. This means the child now
  appears in multiple parents. In the most extreme case, an item might be
  referenced in two different sets of `children`, _and_ have a third,
  completely unrelated `parentid`.
- Deleted a child, and tracked the deletion, but didn't flag the parent for
  reupload. The parent folder now has a tombstone child.
- Tracked and uploaded items that shouldn't exist on the server at all,
  like the left pane or reading list roots (bug 1309255).
- Missed new folders created during a sync, creating holes in the tree.

Newer clients shouldn't do this, but we might still have inconsistent
records on the server that will confuse older clients. Additionally, Firefox
for iOS includes a much stricter bookmarks engine that refuses to sync if
it detects inconsistencies.

# Divergences

To work around this, our tree lets the structure _diverge_. This allows:

- Items with multiple parents.
- Items with missing `parentid`s.
- Folders with `children` whose `parentid`s don't match the folder.
- Items whose `parentid`s don't mention the item in their `children`.
- Items with `parentid`s that point to nonexistent or deleted folders.
- Folders with nonexistent `children`.
- Non-syncable items, like custom roots.
- Any combination of these.

Each item in the tree has an `EntryParentFrom` tag that indicates where
its structure comes from. Structure from `children` is validated and
resolved at `insert` time, so trying to add an item to a parent that
doesn't exist or isn't a folder returns a `MissingParent` or
`InvalidParent` error.

Structure from `parentid`, if it diverges from `children`, is resolved at
merge time, when the merger walks the complete tree. You can think of this
distinction as similar to early vs. late binding. The `parentid`, if
different from the parent's `children`, might not exist in the tree at
`insert` time, either because the parent hasn't been added yet, or because
it doesn't exist in the tree at all.

# Resolving divergences

Walking the tree, using `Tree::node_for_guid`, `Node::parent`, and
`Node::children`, resolves divergences using these rules:

1. Items that appear in multiple `children`, and items with mismatched
   `parentid`s, use the chronologically newer parent, based on the parent's
   last modified time. We always prefer structure from `children` over
   `parentid,` because `children` also gives us the item's position.
2. Items that aren't mentioned in any parent's `children`, but have a
   `parentid` that references an existing folder in the tree, are reparented
   to the end of that folder, after the folder's `children`.
3. Items that reference a nonexistent or non-folder `parentid`, or don't
   have a `parentid` at all, are reparented to the default folder, after any
   `children` and items from rule 2.
4. If the default folder isn't set, or doesn't exist, items from rule 3 are
   reparented to the root instead.

The result is a well-formed tree structure that can be merged. The merger
detects if the structure diverged, and flags affected items for reupload.

Closes #18.",linacambridge,41387967,2019-01-09T14:54:41Z,CONTRIBUTOR,True,1180,333,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,ceb45d6b6558f2db8726b8349c91456bda9f4c01,"Include nodes from both sides for each `MergeState`.

We need this to apply the merged tree, when we join to the local and
remote trees."
116,https://api.github.com/repos/mozilla/dogear/pulls/19,19,Fix up diverging structure in bookmark trees,"In a well-formed tree:

- Each item exists in exactly one folder. Two different folder's
  `children` should never reference the same item.
- Each folder contains existing children. A folder's `children` should
  never reference tombstones, or items that don't exist in the tree at all.
- Each item has a `parentid` that agrees with its parent's `children`. In
  other words, if item B's `parentid` is A, then A's `children` should
  contain B.

Because of Reasons, things are (a lot) messier in practice.

# Structure inconsistencies

Sync stores structure in two places: a `parentid` property on each item,
which points to its parent's GUID, and a list of ordered `children` on the
item's parent. They're duplicated because, historically, Sync clients didn't
stage incoming records. Instead, they applied records one at a time,
directly to the live local tree. This meant that, if a client saw a child
before its parent, it would first use the `parentid` to decide where to keep
the child, then fix up parents and positions using the parent's `children`.

This is also why moving an item into a different folder uploads records for
the item, old folder, and new folder. The item has a new `parentid`, and the
folders have new `children`. Similarly, deleting an item uploads a tombstone
for the item, and a record for the item's old parent.

Unfortunately, bugs (bug 1258127) and missing features (bug 1253051) in
older clients sometimes caused them to upload invalid or incomplete changes.
For example, a client might have:

- Uploaded a moved child, but not its parents. This means the child now
  appears in multiple parents. In the most extreme case, an item might be
  referenced in two different sets of `children`, _and_ have a third,
  completely unrelated `parentid`.
- Deleted a child, and tracked the deletion, but didn't flag the parent for
  reupload. The parent folder now has a tombstone child.
- Tracked and uploaded items that shouldn't exist on the server at all,
  like the left pane or reading list roots (bug 1309255).
- Missed new folders created during a sync, creating holes in the tree.

Newer clients shouldn't do this, but we might still have inconsistent
records on the server that will confuse older clients. Additionally, Firefox
for iOS includes a much stricter bookmarks engine that refuses to sync if
it detects inconsistencies.

# Divergences

To work around this, our tree lets the structure _diverge_. This allows:

- Items with multiple parents.
- Items with missing `parentid`s.
- Folders with `children` whose `parentid`s don't match the folder.
- Items whose `parentid`s don't mention the item in their `children`.
- Items with `parentid`s that point to nonexistent or deleted folders.
- Folders with nonexistent `children`.
- Non-syncable items, like custom roots.
- Any combination of these.

Each item in the tree has an `EntryParentFrom` tag that indicates where
its structure comes from. Structure from `children` is validated and
resolved at `insert` time, so trying to add an item to a parent that
doesn't exist or isn't a folder returns a `MissingParent` or
`InvalidParent` error.

Structure from `parentid`, if it diverges from `children`, is resolved at
merge time, when the merger walks the complete tree. You can think of this
distinction as similar to early vs. late binding. The `parentid`, if
different from the parent's `children`, might not exist in the tree at
`insert` time, either because the parent hasn't been added yet, or because
it doesn't exist in the tree at all.

# Resolving divergences

Walking the tree, using `Tree::node_for_guid`, `Node::parent`, and
`Node::children`, resolves divergences using these rules:

1. Items that appear in multiple `children`, and items with mismatched
   `parentid`s, use the chronologically newer parent, based on the parent's
   last modified time. We always prefer structure from `children` over
   `parentid,` because `children` also gives us the item's position.
2. Items that aren't mentioned in any parent's `children`, but have a
   `parentid` that references an existing folder in the tree, are reparented
   to the end of that folder, after the folder's `children`.
3. Items that reference a nonexistent or non-folder `parentid`, or don't
   have a `parentid` at all, are reparented to the default folder, after any
   `children` and items from rule 2.
4. If the default folder isn't set, or doesn't exist, items from rule 3 are
   reparented to the root instead.

The result is a well-formed tree structure that can be merged. The merger
detects if the structure diverged, and flags affected items for reupload.

Closes #18.",linacambridge,41387967,2019-01-09T14:54:41Z,CONTRIBUTOR,True,1180,333,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,07fd1615e05530ddaa82e77e53a19157f2f733dd,"Refactor error handling in `Store`.

* Fix infinite recursion in `fmt::Display::fmt()` for `Error`.
* Make `Store` generic over the error type. This allows callers to
  provide their own error types that unify with Dogear errors,
  `nsresult`s, and others, instead of requiring them to wrap their
  errors into `ErrorKind::Storage(...)`.
* Forward decoding errors from `Guid::from{utf8, uft16}()`.
* Rename `ErrorKind::GenerateGuid` to `ErrorKind::InvalidGuid`.
* Move `dogear::merge` into `Store::merge`."
117,https://api.github.com/repos/mozilla/dogear/pulls/17,17,"Add an ""unchanged"" merge state","Unchanged items exist on both sides, and don't need to be updated or uploaded. They're not handled specially in the merger (except to set flags in the tests), but we can apply them more efficiently, since we won't need to update their value or structure.

This is also a much cleaner way to handle the ""exists only on one side"" case in `use_remote` and `needs_upload`.

@bbangert, CCing you because this might be a good PR for us to pair review on Live Share, too! 👀",linacambridge,41387967,2018-12-14T06:08:54Z,CONTRIBUTOR,True,63,62,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,a4ebc75a5adf6982edc71948d374256dff3832e9,Remove `Item::newer_than`.
118,https://api.github.com/repos/mozilla/dogear/pulls/17,17,"Add an ""unchanged"" merge state","Unchanged items exist on both sides, and don't need to be updated or uploaded. They're not handled specially in the merger (except to set flags in the tests), but we can apply them more efficiently, since we won't need to update their value or structure.

This is also a much cleaner way to handle the ""exists only on one side"" case in `use_remote` and `needs_upload`.

@bbangert, CCing you because this might be a good PR for us to pair review on Live Share, too! 👀",linacambridge,41387967,2018-12-14T06:08:54Z,CONTRIBUTOR,True,63,62,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,43ce56cbd91852215ebddaff96f80d02f972f7df,"Add an ""unchanged"" merge state.

Unchanged items exist on both sides, and don't need to be updated or
uploaded. They're not handled specially in Dogear, but we can apply
them more efficiently, since we won't need to update their value
or structure.

This also lets us clean up `MergedNode::use_remote()` and
`needs_upload()`."
119,https://api.github.com/repos/mozilla/dogear/pulls/17,17,"Add an ""unchanged"" merge state","Unchanged items exist on both sides, and don't need to be updated or uploaded. They're not handled specially in the merger (except to set flags in the tests), but we can apply them more efficiently, since we won't need to update their value or structure.

This is also a much cleaner way to handle the ""exists only on one side"" case in `use_remote` and `needs_upload`.

@bbangert, CCing you because this might be a good PR for us to pair review on Live Share, too! 👀",linacambridge,41387967,2018-12-14T06:08:54Z,CONTRIBUTOR,True,63,62,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,d31a585ea48de9adaedb2ab5b4439e417eae681f,`MergeState` only needs to hold the decided node.
120,https://api.github.com/repos/mozilla/dogear/pulls/16,16,Remove rustfmt,"`rustup component add rustfmt{-preview}` sadly no longer works on Nightly, and we don't use `cargo fmt --all -- --check` on Travis. Let's remove it entirely for now; we can always add it back later.",linacambridge,41387967,2018-12-12T22:32:14Z,CONTRIBUTOR,True,1,16,3,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,6b6f00f8a1a0dc49947bc3231b456a3237ea4faf,Remove rustfmt.
121,https://api.github.com/repos/mozilla/dogear/pulls/15,15,Ensure we set upload flags correctly for merged items,"The way we flag new and merged local items for upload is a [bit of a mess](https://bugzilla.mozilla.org/show_bug.cgi?id=1496878). 🌪 This likely explains why we're seeing more `parentid` mismatches for the new bookmarks engine on Desktop, too.

Previously, when we preferred a local move over a remote move, we flagged the _parent_ for reupload, but not the _child_. Older Desktops and Android use the child's `parentid` to determine the correct parent, not the parent's `children`, and iOS expects the two to match. Desktop accidentally did the right thing in some cases because we didn't reset `needs_merge` for newer local values. However, if we _did_ reset the flag, we'd update the new parents, but not the child...meaning the child on the server would end up with a stale `parentid`, even if it was flagged correctly before merging. Oops. 😬

I also took the chance to simplify Sync change tracking for uploads. Now, all merged nodes with a `LocalWithNewStructure` or `RemoteWithNewStructure` state should be uploaded, and all others shouldn't.",linacambridge,41387967,2018-10-06T00:51:29Z,CONTRIBUTOR,True,173,106,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,47335a2cafb15a4e612e9e8bf846cd8b6f1900b7,"Mark merged nodes with new structure as unmerged.

This is useful for testing which items are flagged for upload."
122,https://api.github.com/repos/mozilla/dogear/pulls/15,15,Ensure we set upload flags correctly for merged items,"The way we flag new and merged local items for upload is a [bit of a mess](https://bugzilla.mozilla.org/show_bug.cgi?id=1496878). 🌪 This likely explains why we're seeing more `parentid` mismatches for the new bookmarks engine on Desktop, too.

Previously, when we preferred a local move over a remote move, we flagged the _parent_ for reupload, but not the _child_. Older Desktops and Android use the child's `parentid` to determine the correct parent, not the parent's `children`, and iOS expects the two to match. Desktop accidentally did the right thing in some cases because we didn't reset `needs_merge` for newer local values. However, if we _did_ reset the flag, we'd update the new parents, but not the child...meaning the child on the server would end up with a stale `parentid`, even if it was flagged correctly before merging. Oops. 😬

I also took the chance to simplify Sync change tracking for uploads. Now, all merged nodes with a `LocalWithNewStructure` or `RemoteWithNewStructure` state should be uploaded, and all others shouldn't.",linacambridge,41387967,2018-10-06T00:51:29Z,CONTRIBUTOR,True,173,106,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,bdfe297c11d0c9da21d1856b4cfaf986c959abb3,"Fix the logic in `two_way_merge` for deciding the value state.

Refactoring made the previous buggy behavior more obvious. If the node
is changed locally, but not remotely, we should use the local node and
merge state."
123,https://api.github.com/repos/mozilla/dogear/pulls/15,15,Ensure we set upload flags correctly for merged items,"The way we flag new and merged local items for upload is a [bit of a mess](https://bugzilla.mozilla.org/show_bug.cgi?id=1496878). 🌪 This likely explains why we're seeing more `parentid` mismatches for the new bookmarks engine on Desktop, too.

Previously, when we preferred a local move over a remote move, we flagged the _parent_ for reupload, but not the _child_. Older Desktops and Android use the child's `parentid` to determine the correct parent, not the parent's `children`, and iOS expects the two to match. Desktop accidentally did the right thing in some cases because we didn't reset `needs_merge` for newer local values. However, if we _did_ reset the flag, we'd update the new parents, but not the child...meaning the child on the server would end up with a stale `parentid`, even if it was flagged correctly before merging. Oops. 😬

I also took the chance to simplify Sync change tracking for uploads. Now, all merged nodes with a `LocalWithNewStructure` or `RemoteWithNewStructure` state should be uploaded, and all others shouldn't.",linacambridge,41387967,2018-10-06T00:51:29Z,CONTRIBUTOR,True,173,106,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,2b65f9290f41a2cc4a25f4b842922bf0fbb441ec,"Ensure we flag newer locally moved children for reupload.

This likely explains why we're seeing more `parentid` mismatches for
the new bookmarks engine. Previously, when we preferred a local move
over a remote move, we flagged the *parent* for reupload, but not the
*child*. However, older Desktops and Android use the child's `parentid`
to determine the correct parent, not the parent's `children`, and iOS
expects the two to match.

The old behavior accidentally did the right thing on Desktop for local
values, since we didn't reset the Sync change counter (`needs_merge`
flag in Dogear). However, we did reset the counter for *remote* values
with a new structure, meaning those children weren't uploaded to the
server...even though they were flagged correctly before merging.

This commit also simplifies Sync change tracking for uploads. Every
merged node wiith a new structure (`LocalWithNewStructure` or
`RemoteWithNewStructure`) should have `syncChangeCounter = 1`, and
all others should have `syncChangeCounter = 0`."
124,https://api.github.com/repos/mozilla/dogear/pulls/15,15,Ensure we set upload flags correctly for merged items,"The way we flag new and merged local items for upload is a [bit of a mess](https://bugzilla.mozilla.org/show_bug.cgi?id=1496878). 🌪 This likely explains why we're seeing more `parentid` mismatches for the new bookmarks engine on Desktop, too.

Previously, when we preferred a local move over a remote move, we flagged the _parent_ for reupload, but not the _child_. Older Desktops and Android use the child's `parentid` to determine the correct parent, not the parent's `children`, and iOS expects the two to match. Desktop accidentally did the right thing in some cases because we didn't reset `needs_merge` for newer local values. However, if we _did_ reset the flag, we'd update the new parents, but not the child...meaning the child on the server would end up with a stale `parentid`, even if it was flagged correctly before merging. Oops. 😬

I also took the chance to simplify Sync change tracking for uploads. Now, all merged nodes with a `LocalWithNewStructure` or `RemoteWithNewStructure` state should be uploaded, and all others shouldn't.",linacambridge,41387967,2018-10-06T00:51:29Z,CONTRIBUTOR,True,173,106,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,c25995e1f6b951469b30aa08136c8b8789b20867,Always update or upload items that only exist on one side.
125,https://api.github.com/repos/mozilla/dogear/pulls/15,15,Ensure we set upload flags correctly for merged items,"The way we flag new and merged local items for upload is a [bit of a mess](https://bugzilla.mozilla.org/show_bug.cgi?id=1496878). 🌪 This likely explains why we're seeing more `parentid` mismatches for the new bookmarks engine on Desktop, too.

Previously, when we preferred a local move over a remote move, we flagged the _parent_ for reupload, but not the _child_. Older Desktops and Android use the child's `parentid` to determine the correct parent, not the parent's `children`, and iOS expects the two to match. Desktop accidentally did the right thing in some cases because we didn't reset `needs_merge` for newer local values. However, if we _did_ reset the flag, we'd update the new parents, but not the child...meaning the child on the server would end up with a stale `parentid`, even if it was flagged correctly before merging. Oops. 😬

I also took the chance to simplify Sync change tracking for uploads. Now, all merged nodes with a `LocalWithNewStructure` or `RemoteWithNewStructure` state should be uploaded, and all others shouldn't.",linacambridge,41387967,2018-10-06T00:51:29Z,CONTRIBUTOR,True,173,106,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,37106803c53f975218a7079169cd70af274cb254,Keep the local state for items unchanged on both sides.
126,https://api.github.com/repos/mozilla/dogear/pulls/14,14,Set up Codecov,"We need to use `sudo: required` for now, to work around travis-ci/travis-ci#9061. 🔧:shipit:",linacambridge,41387967,2018-09-01T00:13:14Z,CONTRIBUTOR,True,67,1,4,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,8d1905041f4527b3887139be7487231b639e474b,Set up Codecov.
127,https://api.github.com/repos/mozilla/dogear/pulls/13,13,Don't allow merging folders and livemarks,"This won't go well if the folder somehow has children on one side. (Livemarks haven't had real children for a while, as seen in [bug 632287](https://bugzilla.mozilla.org/show_bug.cgi?id=632287), but the folder can still be modified locally). Since we're removing livemarks in [bug 1477667](https://bugzilla.mozilla.org/show_bug.cgi?id=1477667), we can probably remove this entirely instead of adding complexity to the merger.",linacambridge,41387967,2018-08-31T03:41:46Z,CONTRIBUTOR,True,35,8,3,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,62a7b5965cce57dec68a3a2784273a9efe37295a,"Don't allow merging folders and livemarks.

This requires removing the entire subtree, in case we're merging a
folder with children on one side, and a livemark on the other. Since
we're removing livemarks in bug 1477667, we can remove this entirely
instead of adding complexity to the merger."
128,https://api.github.com/repos/mozilla/dogear/pulls/12,12,Add a slow string representation for invalid GUIDs,Building on @thomcc's work in #10. Also added the lookup table. 😄,linacambridge,41387967,2018-08-22T06:35:09Z,CONTRIBUTOR,True,117,53,3,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,ad38815eca6c18414554b32982f16ae6abe33704,Add a slow string representation for invalid GUIDs.
129,https://api.github.com/repos/mozilla/dogear/pulls/11,11,Changes to get Vellum working on Desktop,Rolling PR; eventually closes #7.,linacambridge,41387967,2018-08-21T05:52:16Z,CONTRIBUTOR,True,125,26,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,84e97df3d5f5450e8167731d805f8cde391d466f,Match the `env_logger` version used in gkrust.
130,https://api.github.com/repos/mozilla/dogear/pulls/11,11,Changes to get Vellum working on Desktop,Rolling PR; eventually closes #7.,linacambridge,41387967,2018-08-21T05:52:16Z,CONTRIBUTOR,True,125,26,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,b2542f6c4d07d940b3fa002383c7db104a64aca6,Expose public structs.
131,https://api.github.com/repos/mozilla/dogear/pulls/11,11,Changes to get Vellum working on Desktop,Rolling PR; eventually closes #7.,linacambridge,41387967,2018-08-21T05:52:16Z,CONTRIBUTOR,True,125,26,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,07db796c224dda878869afdea11fd2b24ea908d5,Define a `Store` trait and `merge` function. Closes #8.
132,https://api.github.com/repos/mozilla/dogear/pulls/11,11,Changes to get Vellum working on Desktop,Rolling PR; eventually closes #7.,linacambridge,41387967,2018-08-21T05:52:16Z,CONTRIBUTOR,True,125,26,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,c5075cddaf25bc0829ed584ab396528538490d7a,Clean up error kind names.
133,https://api.github.com/repos/mozilla/dogear/pulls/11,11,Changes to get Vellum working on Desktop,Rolling PR; eventually closes #7.,linacambridge,41387967,2018-08-21T05:52:16Z,CONTRIBUTOR,True,125,26,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,580f7e467165bebc07294018401b4df8ef343f7a,Add `Guid::from_bytes` to simplify conversions from `nsString`.
134,https://api.github.com/repos/mozilla/dogear/pulls/11,11,Changes to get Vellum working on Desktop,Rolling PR; eventually closes #7.,linacambridge,41387967,2018-08-21T05:52:16Z,CONTRIBUTOR,True,125,26,7,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,69ac8d506f6ee95f8cde8b3591cdced6b5e14f9c,Don't package unnecessary files.
135,https://api.github.com/repos/mozilla/dogear/pulls/10,10,Use Arc<str> instead of String for guids (fixes #9),"This is Arc and not Rc, since

- lazy_static requires it (although we could just use `str` there and construct them when using)
- we have some threading requirements i don't fully understand, but you cannot send Rc to different threads.

It should be trivial to change this if we decide to.

",thomcc,860665,2018-08-16T15:42:42Z,CONTRIBUTOR,True,213,96,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,81e9ca424e54ed41dec1e26fb4aa94d05bb5ef9f,Store GUIDs as an array of [u8; 12] (fixes #9 by making it pointless)
136,https://api.github.com/repos/mozilla/dogear/pulls/5,5,Ascii tree logging,"Builds on top of #1 and fixes #2.
This follows the desktop implementation.
Example of output:

```
+ root________ ((Folder; Age = 0ms)
| + toolbar_____ ((Folder; Age = 0ms)
| | + folderAAAAAA ((Folder; Age = 0ms)
| | | - bookmarkFFFF ((Bookmark; Age = 0ms)
| + menu________ ((Folder; Age = 0ms)
| | + folderCCCCCC ((Folder; Age = 0ms)
| | | + folderDDDDDD ((Folder; Age = 0ms)
| | | | - bookmarkGGGG ((Bookmark; Age = 0ms)
Deleted: []
```

Note: `itertools` is used to allow `join()` on iterators.",eoger,6424575,2018-08-08T19:07:25Z,CONTRIBUTOR,False,722,311,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,37b1f35addc2b4d88d4ad9fac2cf7d50bc7cd5e7,Implement `Tree`.
137,https://api.github.com/repos/mozilla/dogear/pulls/5,5,Ascii tree logging,"Builds on top of #1 and fixes #2.
This follows the desktop implementation.
Example of output:

```
+ root________ ((Folder; Age = 0ms)
| + toolbar_____ ((Folder; Age = 0ms)
| | + folderAAAAAA ((Folder; Age = 0ms)
| | | - bookmarkFFFF ((Bookmark; Age = 0ms)
| + menu________ ((Folder; Age = 0ms)
| | + folderCCCCCC ((Folder; Age = 0ms)
| | | + folderDDDDDD ((Folder; Age = 0ms)
| | | | - bookmarkGGGG ((Bookmark; Age = 0ms)
Deleted: []
```

Note: `itertools` is used to allow `join()` on iterators.",eoger,6424575,2018-08-08T19:07:25Z,CONTRIBUTOR,False,722,311,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,232b58f48efb35f7ed7762dc3b24fd90f733b604,Fix up doc comments and nits.
138,https://api.github.com/repos/mozilla/dogear/pulls/5,5,Ascii tree logging,"Builds on top of #1 and fixes #2.
This follows the desktop implementation.
Example of output:

```
+ root________ ((Folder; Age = 0ms)
| + toolbar_____ ((Folder; Age = 0ms)
| | + folderAAAAAA ((Folder; Age = 0ms)
| | | - bookmarkFFFF ((Bookmark; Age = 0ms)
| + menu________ ((Folder; Age = 0ms)
| | + folderCCCCCC ((Folder; Age = 0ms)
| | | + folderDDDDDD ((Folder; Age = 0ms)
| | | | - bookmarkGGGG ((Bookmark; Age = 0ms)
Deleted: []
```

Note: `itertools` is used to allow `join()` on iterators.",eoger,6424575,2018-08-08T19:07:25Z,CONTRIBUTOR,False,722,311,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,36a1db691dab5363019516fa734c9f67f3b55b08,Add a test for complex orphaning.
139,https://api.github.com/repos/mozilla/dogear/pulls/5,5,Ascii tree logging,"Builds on top of #1 and fixes #2.
This follows the desktop implementation.
Example of output:

```
+ root________ ((Folder; Age = 0ms)
| + toolbar_____ ((Folder; Age = 0ms)
| | + folderAAAAAA ((Folder; Age = 0ms)
| | | - bookmarkFFFF ((Bookmark; Age = 0ms)
| + menu________ ((Folder; Age = 0ms)
| | + folderCCCCCC ((Folder; Age = 0ms)
| | | + folderDDDDDD ((Folder; Age = 0ms)
| | | | - bookmarkGGGG ((Bookmark; Age = 0ms)
Deleted: []
```

Note: `itertools` is used to allow `join()` on iterators.",eoger,6424575,2018-08-08T19:07:25Z,CONTRIBUTOR,False,722,311,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,d20a55b866a4cb9dd5366ce82443860ba9a6c642,Add ASCII art tree
140,https://api.github.com/repos/mozilla/dogear/pulls/5,5,Ascii tree logging,"Builds on top of #1 and fixes #2.
This follows the desktop implementation.
Example of output:

```
+ root________ ((Folder; Age = 0ms)
| + toolbar_____ ((Folder; Age = 0ms)
| | + folderAAAAAA ((Folder; Age = 0ms)
| | | - bookmarkFFFF ((Bookmark; Age = 0ms)
| + menu________ ((Folder; Age = 0ms)
| | + folderCCCCCC ((Folder; Age = 0ms)
| | | + folderDDDDDD ((Folder; Age = 0ms)
| | | | - bookmarkGGGG ((Bookmark; Age = 0ms)
Deleted: []
```

Note: `itertools` is used to allow `join()` on iterators.",eoger,6424575,2018-08-08T19:07:25Z,CONTRIBUTOR,False,722,311,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,1724161649c7034e9c6927d0719e3215d44cd78e,Invert match arms for consistency
141,https://api.github.com/repos/mozilla/dogear/pulls/5,5,Ascii tree logging,"Builds on top of #1 and fixes #2.
This follows the desktop implementation.
Example of output:

```
+ root________ ((Folder; Age = 0ms)
| + toolbar_____ ((Folder; Age = 0ms)
| | + folderAAAAAA ((Folder; Age = 0ms)
| | | - bookmarkFFFF ((Bookmark; Age = 0ms)
| + menu________ ((Folder; Age = 0ms)
| | + folderCCCCCC ((Folder; Age = 0ms)
| | | + folderDDDDDD ((Folder; Age = 0ms)
| | | | - bookmarkGGGG ((Bookmark; Age = 0ms)
Deleted: []
```

Note: `itertools` is used to allow `join()` on iterators.",eoger,6424575,2018-08-08T19:07:25Z,CONTRIBUTOR,False,722,311,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,850d2a471aa69cac68aa982811339ba10207717c,Emojis 🤪
142,https://api.github.com/repos/mozilla/dogear/pulls/5,5,Ascii tree logging,"Builds on top of #1 and fixes #2.
This follows the desktop implementation.
Example of output:

```
+ root________ ((Folder; Age = 0ms)
| + toolbar_____ ((Folder; Age = 0ms)
| | + folderAAAAAA ((Folder; Age = 0ms)
| | | - bookmarkFFFF ((Bookmark; Age = 0ms)
| + menu________ ((Folder; Age = 0ms)
| | + folderCCCCCC ((Folder; Age = 0ms)
| | | + folderDDDDDD ((Folder; Age = 0ms)
| | | | - bookmarkGGGG ((Bookmark; Age = 0ms)
Deleted: []
```

Note: `itertools` is used to allow `join()` on iterators.",eoger,6424575,2018-08-08T19:07:25Z,CONTRIBUTOR,False,722,311,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,693113d27d6cacda457e8abd3af34dd1dea841f5,cargo fmt
143,https://api.github.com/repos/mozilla/dogear/pulls/5,5,Ascii tree logging,"Builds on top of #1 and fixes #2.
This follows the desktop implementation.
Example of output:

```
+ root________ ((Folder; Age = 0ms)
| + toolbar_____ ((Folder; Age = 0ms)
| | + folderAAAAAA ((Folder; Age = 0ms)
| | | - bookmarkFFFF ((Bookmark; Age = 0ms)
| + menu________ ((Folder; Age = 0ms)
| | + folderCCCCCC ((Folder; Age = 0ms)
| | | + folderDDDDDD ((Folder; Age = 0ms)
| | | | - bookmarkGGGG ((Bookmark; Age = 0ms)
Deleted: []
```

Note: `itertools` is used to allow `join()` on iterators.",eoger,6424575,2018-08-08T19:07:25Z,CONTRIBUTOR,False,722,311,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,4fdb2701a2688c4fab5b8489ac004058cea50cc3,Remove extra parenthesis
144,https://api.github.com/repos/mozilla/dogear/pulls/5,5,Ascii tree logging,"Builds on top of #1 and fixes #2.
This follows the desktop implementation.
Example of output:

```
+ root________ ((Folder; Age = 0ms)
| + toolbar_____ ((Folder; Age = 0ms)
| | + folderAAAAAA ((Folder; Age = 0ms)
| | | - bookmarkFFFF ((Bookmark; Age = 0ms)
| + menu________ ((Folder; Age = 0ms)
| | + folderCCCCCC ((Folder; Age = 0ms)
| | | + folderDDDDDD ((Folder; Age = 0ms)
| | | | - bookmarkGGGG ((Bookmark; Age = 0ms)
Deleted: []
```

Note: `itertools` is used to allow `join()` on iterators.",eoger,6424575,2018-08-08T19:07:25Z,CONTRIBUTOR,False,722,311,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,ca9bcc6eb78a2e5c06e04cde758cfd4639511de8,"Streamline ascii_tree_prefixed across MergedNode and Node

We could probably factorize the ascii_tree_prefixed functions in a helper method
if someone was willing to fight with rust type checking."
145,https://api.github.com/repos/mozilla/dogear/pulls/5,5,Ascii tree logging,"Builds on top of #1 and fixes #2.
This follows the desktop implementation.
Example of output:

```
+ root________ ((Folder; Age = 0ms)
| + toolbar_____ ((Folder; Age = 0ms)
| | + folderAAAAAA ((Folder; Age = 0ms)
| | | - bookmarkFFFF ((Bookmark; Age = 0ms)
| + menu________ ((Folder; Age = 0ms)
| | + folderCCCCCC ((Folder; Age = 0ms)
| | | + folderDDDDDD ((Folder; Age = 0ms)
| | | | - bookmarkGGGG ((Bookmark; Age = 0ms)
Deleted: []
```

Note: `itertools` is used to allow `join()` on iterators.",eoger,6424575,2018-08-08T19:07:25Z,CONTRIBUTOR,False,722,311,2,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,ca01ab8271051f964fe54f9fd42e2eb8747c3858,Address review comments
146,https://api.github.com/repos/mozilla/dogear/pulls/1,1,First working merge,"It's a Rusty bookmark party! 🎉 📚 🔖 🦀 

* Implement `Tree::insert`.
* Overhaul the `Tree` interface. I played around with going a step further and making the tree generic for the item and GUID type, instead of restricting to just `Item` and `String`...but that got unwieldy with `&str` vs. `String`, and then I added `Eq`, which needed yet another trait bound. 😕 At that point, it didn't seem worthwhile.
* Simplify `MergedNode`. We can use the `ValueState` enum to store the preferred node, and statically assert that, for example, we don't have a `Local` state without a local node. ✨ 
* Clean up comments that still mention Places, and fix some review nits.
* Add a test for the (in)famous ""add to folder on one side, delete folder on the other"" scenario. 😄

@thomcc, it would be great if you could take a look when you have cycles. Thanks!",linacambridge,41387967,2018-08-07T07:39:43Z,CONTRIBUTOR,True,1053,403,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,37b1f35addc2b4d88d4ad9fac2cf7d50bc7cd5e7,Implement `Tree`.
147,https://api.github.com/repos/mozilla/dogear/pulls/1,1,First working merge,"It's a Rusty bookmark party! 🎉 📚 🔖 🦀 

* Implement `Tree::insert`.
* Overhaul the `Tree` interface. I played around with going a step further and making the tree generic for the item and GUID type, instead of restricting to just `Item` and `String`...but that got unwieldy with `&str` vs. `String`, and then I added `Eq`, which needed yet another trait bound. 😕 At that point, it didn't seem worthwhile.
* Simplify `MergedNode`. We can use the `ValueState` enum to store the preferred node, and statically assert that, for example, we don't have a `Local` state without a local node. ✨ 
* Clean up comments that still mention Places, and fix some review nits.
* Add a test for the (in)famous ""add to folder on one side, delete folder on the other"" scenario. 😄

@thomcc, it would be great if you could take a look when you have cycles. Thanks!",linacambridge,41387967,2018-08-07T07:39:43Z,CONTRIBUTOR,True,1053,403,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,232b58f48efb35f7ed7762dc3b24fd90f733b604,Fix up doc comments and nits.
148,https://api.github.com/repos/mozilla/dogear/pulls/1,1,First working merge,"It's a Rusty bookmark party! 🎉 📚 🔖 🦀 

* Implement `Tree::insert`.
* Overhaul the `Tree` interface. I played around with going a step further and making the tree generic for the item and GUID type, instead of restricting to just `Item` and `String`...but that got unwieldy with `&str` vs. `String`, and then I added `Eq`, which needed yet another trait bound. 😕 At that point, it didn't seem worthwhile.
* Simplify `MergedNode`. We can use the `ValueState` enum to store the preferred node, and statically assert that, for example, we don't have a `Local` state without a local node. ✨ 
* Clean up comments that still mention Places, and fix some review nits.
* Add a test for the (in)famous ""add to folder on one side, delete folder on the other"" scenario. 😄

@thomcc, it would be great if you could take a look when you have cycles. Thanks!",linacambridge,41387967,2018-08-07T07:39:43Z,CONTRIBUTOR,True,1053,403,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,36a1db691dab5363019516fa734c9f67f3b55b08,Add a test for complex orphaning.
149,https://api.github.com/repos/mozilla/dogear/pulls/1,1,First working merge,"It's a Rusty bookmark party! 🎉 📚 🔖 🦀 

* Implement `Tree::insert`.
* Overhaul the `Tree` interface. I played around with going a step further and making the tree generic for the item and GUID type, instead of restricting to just `Item` and `String`...but that got unwieldy with `&str` vs. `String`, and then I added `Eq`, which needed yet another trait bound. 😕 At that point, it didn't seem worthwhile.
* Simplify `MergedNode`. We can use the `ValueState` enum to store the preferred node, and statically assert that, for example, we don't have a `Local` state without a local node. ✨ 
* Clean up comments that still mention Places, and fix some review nits.
* Add a test for the (in)famous ""add to folder on one side, delete folder on the other"" scenario. 😄

@thomcc, it would be great if you could take a look when you have cycles. Thanks!",linacambridge,41387967,2018-08-07T07:39:43Z,CONTRIBUTOR,True,1053,403,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,edc69b4c7e7303348481013c2fe0a2db3e9e3705,Remove unused `lazy_static` dependency.
150,https://api.github.com/repos/mozilla/dogear/pulls/1,1,First working merge,"It's a Rusty bookmark party! 🎉 📚 🔖 🦀 

* Implement `Tree::insert`.
* Overhaul the `Tree` interface. I played around with going a step further and making the tree generic for the item and GUID type, instead of restricting to just `Item` and `String`...but that got unwieldy with `&str` vs. `String`, and then I added `Eq`, which needed yet another trait bound. 😕 At that point, it didn't seem worthwhile.
* Simplify `MergedNode`. We can use the `ValueState` enum to store the preferred node, and statically assert that, for example, we don't have a `Local` state without a local node. ✨ 
* Clean up comments that still mention Places, and fix some review nits.
* Add a test for the (in)famous ""add to folder on one side, delete folder on the other"" scenario. 😄

@thomcc, it would be great if you could take a look when you have cycles. Thanks!",linacambridge,41387967,2018-08-07T07:39:43Z,CONTRIBUTOR,True,1053,403,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,1cc30e5e59c0f935a3d568f03a7fd72e72bbda30,"Remove special handling for roots.

It's easier to enforce that user content roots aren't moved when
buffering incoming records, instead of special-casing roots in
the merger to always prefer the local structure."
151,https://api.github.com/repos/mozilla/dogear/pulls/1,1,First working merge,"It's a Rusty bookmark party! 🎉 📚 🔖 🦀 

* Implement `Tree::insert`.
* Overhaul the `Tree` interface. I played around with going a step further and making the tree generic for the item and GUID type, instead of restricting to just `Item` and `String`...but that got unwieldy with `&str` vs. `String`, and then I added `Eq`, which needed yet another trait bound. 😕 At that point, it didn't seem worthwhile.
* Simplify `MergedNode`. We can use the `ValueState` enum to store the preferred node, and statically assert that, for example, we don't have a `Local` state without a local node. ✨ 
* Clean up comments that still mention Places, and fix some review nits.
* Add a test for the (in)famous ""add to folder on one side, delete folder on the other"" scenario. 😄

@thomcc, it would be great if you could take a look when you have cycles. Thanks!",linacambridge,41387967,2018-08-07T07:39:43Z,CONTRIBUTOR,True,1053,403,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,a100d3c03f580fc96e076dd6b7ed8c10ea78358e,Port remaining structure change tests.
152,https://api.github.com/repos/mozilla/dogear/pulls/1,1,First working merge,"It's a Rusty bookmark party! 🎉 📚 🔖 🦀 

* Implement `Tree::insert`.
* Overhaul the `Tree` interface. I played around with going a step further and making the tree generic for the item and GUID type, instead of restricting to just `Item` and `String`...but that got unwieldy with `&str` vs. `String`, and then I added `Eq`, which needed yet another trait bound. 😕 At that point, it didn't seem worthwhile.
* Simplify `MergedNode`. We can use the `ValueState` enum to store the preferred node, and statically assert that, for example, we don't have a `Local` state without a local node. ✨ 
* Clean up comments that still mention Places, and fix some review nits.
* Add a test for the (in)famous ""add to folder on one side, delete folder on the other"" scenario. 😄

@thomcc, it would be great if you could take a look when you have cycles. Thanks!",linacambridge,41387967,2018-08-07T07:39:43Z,CONTRIBUTOR,True,1053,403,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,fad717bbec60615ed5b9775b3858b5df0913ad9d,"Disable rustfmt checking on Travis.

`indent_style = ""Visual""` tends to switch between styles. See
rust-lang-nursery/rustfmt#2496."
153,https://api.github.com/repos/mozilla/dogear/pulls/1,1,First working merge,"It's a Rusty bookmark party! 🎉 📚 🔖 🦀 

* Implement `Tree::insert`.
* Overhaul the `Tree` interface. I played around with going a step further and making the tree generic for the item and GUID type, instead of restricting to just `Item` and `String`...but that got unwieldy with `&str` vs. `String`, and then I added `Eq`, which needed yet another trait bound. 😕 At that point, it didn't seem worthwhile.
* Simplify `MergedNode`. We can use the `ValueState` enum to store the preferred node, and statically assert that, for example, we don't have a `Local` state without a local node. ✨ 
* Clean up comments that still mention Places, and fix some review nits.
* Add a test for the (in)famous ""add to folder on one side, delete folder on the other"" scenario. 😄

@thomcc, it would be great if you could take a look when you have cycles. Thanks!",linacambridge,41387967,2018-08-07T07:39:43Z,CONTRIBUTOR,True,1053,403,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,ae6bcdfb2fec4faaf4a3251e15c6fcedf2aeb6d6,Remove `ContentDupeKey` and use an enum for `Content` instead.
154,https://api.github.com/repos/mozilla/dogear/pulls/1,1,First working merge,"It's a Rusty bookmark party! 🎉 📚 🔖 🦀 

* Implement `Tree::insert`.
* Overhaul the `Tree` interface. I played around with going a step further and making the tree generic for the item and GUID type, instead of restricting to just `Item` and `String`...but that got unwieldy with `&str` vs. `String`, and then I added `Eq`, which needed yet another trait bound. 😕 At that point, it didn't seem worthwhile.
* Simplify `MergedNode`. We can use the `ValueState` enum to store the preferred node, and statically assert that, for example, we don't have a `Local` state without a local node. ✨ 
* Clean up comments that still mention Places, and fix some review nits.
* Add a test for the (in)famous ""add to folder on one side, delete folder on the other"" scenario. 😄

@thomcc, it would be great if you could take a look when you have cycles. Thanks!",linacambridge,41387967,2018-08-07T07:39:43Z,CONTRIBUTOR,True,1053,403,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,b617eadd76f4b322a03f634f510ee6d8905b3042,"Remove unnecessary use of `Box`, since `Vec` is heap-allocated."
155,https://api.github.com/repos/mozilla/dogear/pulls/1,1,First working merge,"It's a Rusty bookmark party! 🎉 📚 🔖 🦀 

* Implement `Tree::insert`.
* Overhaul the `Tree` interface. I played around with going a step further and making the tree generic for the item and GUID type, instead of restricting to just `Item` and `String`...but that got unwieldy with `&str` vs. `String`, and then I added `Eq`, which needed yet another trait bound. 😕 At that point, it didn't seem worthwhile.
* Simplify `MergedNode`. We can use the `ValueState` enum to store the preferred node, and statically assert that, for example, we don't have a `Local` state without a local node. ✨ 
* Clean up comments that still mention Places, and fix some review nits.
* Add a test for the (in)famous ""add to folder on one side, delete folder on the other"" scenario. 😄

@thomcc, it would be great if you could take a look when you have cycles. Thanks!",linacambridge,41387967,2018-08-07T07:39:43Z,CONTRIBUTOR,True,1053,403,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,23218d1c8fa0b226c451575d7372401bc3077523,Use `impl Iterator` with a lifetime bound instead of `collect`.
156,https://api.github.com/repos/mozilla/dogear/pulls/1,1,First working merge,"It's a Rusty bookmark party! 🎉 📚 🔖 🦀 

* Implement `Tree::insert`.
* Overhaul the `Tree` interface. I played around with going a step further and making the tree generic for the item and GUID type, instead of restricting to just `Item` and `String`...but that got unwieldy with `&str` vs. `String`, and then I added `Eq`, which needed yet another trait bound. 😕 At that point, it didn't seem worthwhile.
* Simplify `MergedNode`. We can use the `ValueState` enum to store the preferred node, and statically assert that, for example, we don't have a `Local` state without a local node. ✨ 
* Clean up comments that still mention Places, and fix some review nits.
* Add a test for the (in)famous ""add to folder on one side, delete folder on the other"" scenario. 😄

@thomcc, it would be great if you could take a look when you have cycles. Thanks!",linacambridge,41387967,2018-08-07T07:39:43Z,CONTRIBUTOR,True,1053,403,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,72b3413855a204adc10b046a6f90e8580c8e916d,Replace `panic` with `assert`.
157,https://api.github.com/repos/mozilla/dogear/pulls/1,1,First working merge,"It's a Rusty bookmark party! 🎉 📚 🔖 🦀 

* Implement `Tree::insert`.
* Overhaul the `Tree` interface. I played around with going a step further and making the tree generic for the item and GUID type, instead of restricting to just `Item` and `String`...but that got unwieldy with `&str` vs. `String`, and then I added `Eq`, which needed yet another trait bound. 😕 At that point, it didn't seem worthwhile.
* Simplify `MergedNode`. We can use the `ValueState` enum to store the preferred node, and statically assert that, for example, we don't have a `Local` state without a local node. ✨ 
* Clean up comments that still mention Places, and fix some review nits.
* Add a test for the (in)famous ""add to folder on one side, delete folder on the other"" scenario. 😄

@thomcc, it would be great if you could take a look when you have cycles. Thanks!",linacambridge,41387967,2018-08-07T07:39:43Z,CONTRIBUTOR,True,1053,403,5,Firefox Sync's bookmark tree merging algorithm. 📚,Rust,46ad636f73e8bc54ba46dc4f590c5913fc4bd0fd,Remove `Eq` implementation for `Tree`; make `PartialEq` test-only.
